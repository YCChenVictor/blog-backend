{"items":[{"title":"(software) Main","content":"(software) MainPurposeTo acquire the skills and knowledge necessary to design, develop, and utilize digital tools and applications to solve problems and improve efficiency in various domains.ConceptSoftware is a set of instructions and data that tell a computer what to do.Fundamental KnowledgeComplexityComplexity is a fundamental characteristic of systems, phenomena, and processes that exhibit intricate interconnections, dependencies, and behaviors. It involves the study and understanding of intricate patterns, emergent properties, and nonlinear dynamics, challenging traditional reductionist approaches and requiring holistic perspectives to unravel its multifaceted nature. For more information, please refer to complexity.Data Structures and AlgorithmsData Structures and Algorithms (DSA) are essential foundations in software development, providing the tools and techniques to organize and manipulate data efficiently, optimize code performance, and solve complex problems in a systematic and scalable manner. Mastery of DSA enables developers to design robust software solutions, improve algorithmic efficiency, and create optimized code for various applications and domains.Object Oriented DesignObject-oriented design is a fundamental aspect of software development, emphasizing the creation of elegant and maintainable code through the organization of classes and methods to solve problems or represent real-life entities. By applying object-oriented principles, developers can achieve modularity, reusability, and improved quality in their software systems. For more information, please refer to object oriented design.System DesignSystem design involves creating a blueprint for the structure and organization of a software system, considering factors such as architecture, modules, interfaces, and data flow. It aims to transform requirements into an efficient and scalable solution that meets the desired goals and objectives of the system. For more information, please refer to system design.RefactorRefactoring is the process of improving code quality and structure without changing its external behavior, essential for enhancing software maintainability and reducing technical debt. It involves making small, incremental changes to optimize code, making it easier to understand and extend. For more information, please refer to refactor.System softwareThis type of software is designed to manage and control the hardware and software resources of a computer system. Examples include operating systems like Windows, macOS, and Linux, as well as device drivers and utility programs like antivirus software and disk management tools. For more information, please refer to operating systems.Web Application softwareThis type of software is designed for specific tasks or applications, such as word processing, spreadsheet creation, email management, and graphic design. Examples include Microsoft Office, Adobe Creative Suite, and Google Chrome.Plan and DesignPlan and design the user interface and functionality of your web application.Server-side renderingAdvantage: Efficient search engine indexing, better performance on low-powered devices, and improved accessibility.Concept: Generates the HTML content on the server and sending it to the client's web browser for display.Example: RailsClient-side rendering with a separation of concernsAdvantage: This approach offers a more interactive and responsive user experience since the client can manipulate the DOM and fetch data asynchronously without full page reloads.Concept: The frontend is the user-facing part of an application responsible for displaying and interacting with the interface, the backend handles data processing and logic, and Token-based authentication and authorization mechanisms ensure secure data transmission between the frontend and backend by utilizing tokens as digital credentials for validating user identity and permissions.Example: React + NodeFrontend[React] is a popular JavaScript library for building user interfaces, known for its efficient rendering and component-based architecture. Developed by Facebook, React allows developers to create reusable UI components and seamlessly update them as the application state changes, resulting in faster and more interactive web applications.BackendFramework: [Express], or [Ruby on Rails]DatabaseTestTest-Driven Development (TDD) involves writing tests before code to guide development, ensuring early and thorough software testing and aligning code with intended functionality, ultimately enhancing code quality and reducing defects. TDD's approach helps catch issues early, leading to more reliable software and efficient development.Package ManagersJavascript: [Npm], [Yarn]Ruby: [Gem]Deploy and Maintain[Deploy] your web application to a web serverMaintain it by regularly updating it with bug fixes and [security] patches[scale up] the application to handle increased traffic or integrating it with other systems.[Quality Assurance]Embedded softwareThis type of software is designed to control and manage hardware devices and systems, and is often built into the devices themselves. Examples include the software that controls a car's engine, a digital camera's image processing, or a smart thermostat's temperature control.[Robotic]","url":"/blog/software/main"},{"title":"Software","content":"","url":"/blog/software"},{"title":"(dsa) Complexity","content":"(dsa) ComplexityPurposeWith concept of complexity, we can evaluate solution for a problem before diving in.How?Math ConceptComplexity quantifies the maximum resources required to solve a problem or execute an algorithm, aiding in identifying efficient algorithms for optimal problem-solving by understanding the relationship between resource usage and input size; for example, the total time to create x books may be as follow:Time(n) = 4n^3 + 4n^2 + 3However, in real world problems, precise function to describe the total time of producing n amount of books does not exist at all, so we use asymptotic notations.Asymptotic NotationsThere are commonly used notations in computer science, such as big-O (O), big-theta (Θ), and big-omega (Ω), which are used to describe and analyze the time or space complexity of algorithms. For more detailed definitions and explanations of these notations, I recommend referring to reputable academic sources available online and we only focus on the defination of industry here.The defination of O in industry is the same as the defination of Θ in academia; that isThen f(n) is an element of of g(n), which is what industry care about (, big-O); for example, is an element of ; then we can use to describe the complexity of . The following plot demonstrates that is wrapped by and after <canvas id=\"big-o-graph\" width=\"400\" height=\"200\" class='bg-white'></canvas><script>\tconst xValues = [];\tconst y1Values = [];\tconst y2Values = [];\tconst y3Values = [];\tfor (let x = 0; x <= 300; x++) {\t\txValues.push(x);\t\ty1Values.push(3*x);\t\ty2Values.push(x);\t\ty3Values.push(2*x+100);\t}\tconst ctx = document.getElementById(\"big-o-graph\").getContext(\"2d\");\tconst myChart = new Chart(ctx, {\t\ttype: \"line\",\t\tdata: {\t\t\tlabels: xValues,\t\t\tdatasets: [\t\t\t\t{\t\t\t\t\tlabel: \"y = 3x\",\t\t\t\t\tdata: y1Values,\t\t\t\t\tborderColor: \"red\",\t\t\t\t\tfill: false\t\t\t\t},\t\t\t\t{\t\t\t\t\tlabel: \"y = x\",\t\t\t\t\tdata: y2Values,\t\t\t\t\tborderColor: \"blue\",\t\t\t\t\tfill: false\t\t\t\t},\t\t\t\t{\t\t\t\t\tlabel: \"y = 2x+100\",\t\t\t\t\tdata: y3Values,\t\t\t\t\tborderColor: \"green\",\t\t\t\t\tfill: false\t\t\t\t}\t\t\t]\t\t},\t\toptions: { plugins: { customCanvasBackgroundColor: { color: 'lightGreen', } } }\t});</script>Notation SimplificationBased on the defination, we know that the big O of is and also is because of That is, all the constant number can be ignored., where a is constant, where a is constant, where a is constant, where a is constantTime ComplexityRecap, the definition of big-O (O) in industry is the same as big-theta (Θ) in academia. The meaning of Time complexity = O(n) is that the time taken by the algorithm increases proportionally with the size of the input.Amortized TimeIn certain data structures, the time complexity of specific operations may vary significantly; for example, an array resizing during element addition takes O(n) time, yet most additions are constant time O(1), leading us to evaluate the average time taken by a sequence of operations rather than a single operation.Amortized time complexity analysis involves dividing the total time taken by a sequence of operations by the number of operations. This gives us the average time taken per operation, which is a more useful measure of the data structure's performance than the worst-case time complexity of a single operation.Accounting method, which involves assigning a cost to each operation and using the cost to pay for future operations. For example, in an array with dynamic resizing, we could assign a cost of 1 to each add operation, and use the extra time taken by the occasional resize operation to pay for the cost of the future operations.Example: Array ResizingSuppose we init an array with space of 4 and when we add the fifth element, we need to resize the array, going to have O(n) complexity.After the resizing, we can have another four space for the 5-8 element. That is, the time complexity of this space adding process, O(n) should actually be added to the next 5-8 element adding.If we divide O(n) to the next 4 elements, then the amortized time complexity will be O(1).space complexityThe meaning of Space complexity = O(n) is that the space taken by the algorithm increases proportionally with the size of the input.Conceptual ExampleTwo Liner Iterationcodefor (let i = 0; i < arrayA.length; i++) { console.log(arrayA[i])}for (let i = 0; i < arrayB.length; i++) { console.log(arrayB[i])}Time complexity = O(A + B)Picks elements from arrayA, each pick = O(1)Picks elements from arrayB, each pick = O(1)Space complexity = O(1)Only need a space for i => O(1)Iteration in An Iterationcodefor (let i = 0; i < arrayA.length; i++) { for (let j = 0; j < arrayB.length; j++) { console.log(arrayA[i] + arrayB[j]) }}Time complexity = O(A * B)A will be query with i and B will be query with j in O(1) eachThe combination of (i, j) = [0..lengthOfA] x [0..lengthOfB]Space complexity = O(2) = O(1)The space required by i and j is constantRecursive Binary Searchcodefunction binarySearch(array, target) { let low = 0; let high = array.length - 1; while (low <= high) { let middle = Math.floor((low + high) / 2); if (array[middle] === target) { return true; } if (target < array[middle]) { high = middle - 1; } else { low = middle + 1; } } return false;}time complexity = O(log N)Given the number of the elements in an array is 16, then it at most need to work through 5 elements to find the target with steps: the middle element of 16 elements (step 1) -> the middle element of 8 elements (step 2) -> the middle element of 4 elements (step 3) -> the middle element of 2 elements (step 4) -> the middle element of 1 element (step 5)We can describe the number of traverse (k) with the number of elements (N) as follow: , so the complexity = Space complexity = O(log N) for middleIndexAgain, given the elements in an array is 16, at most need to work through 5 elements. Because it is recursive, before we find the answer, all the binarySearch will be store in stack and wait the final binarySearch to return answer. Because each binarySearch need one middleIndex, O(1) and it will also be 5 steps, so the space complexity is also O(log N)Recursive, Fibonacci Seriescodefunction fibonacci(n) { if (n < 2) { return n; } else { return fibonacci(n - 1) + fibonacci(n - 2); }}plot#mark84897{font-family:monospace;font-size:16px;fill:#333;}#mark84897 .error-icon{fill:#552222;}#mark84897 .error-text{fill:#552222;stroke:#552222;}#mark84897 .edge-thickness-normal{stroke-width:2px;}#mark84897 .edge-thickness-thick{stroke-width:3.5px;}#mark84897 .edge-pattern-solid{stroke-dasharray:0;}#mark84897 .edge-pattern-dashed{stroke-dasharray:3;}#mark84897 .edge-pattern-dotted{stroke-dasharray:2;}#mark84897 .marker{fill:#333333;stroke:#333333;}#mark84897 .marker.cross{stroke:#333333;}#mark84897 svg{font-family:monospace;font-size:16px;}#mark84897 .label{font-family:monospace;color:#333;}#mark84897 .cluster-label text{fill:#333;}#mark84897 .cluster-label span,#mark84897 p{color:#333;}#mark84897 .label text,#mark84897 span,#mark84897 p{fill:#333;color:#333;}#mark84897 .node rect,#mark84897 .node circle,#mark84897 .node ellipse,#mark84897 .node polygon,#mark84897 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark84897 .flowchart-label text{text-anchor:middle;}#mark84897 .node .label{text-align:center;}#mark84897 .node.clickable{cursor:pointer;}#mark84897 .arrowheadPath{fill:#333333;}#mark84897 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark84897 .flowchart-link{stroke:#333333;fill:none;}#mark84897 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark84897 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark84897 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark84897 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark84897 .cluster text{fill:#333;}#mark84897 .cluster span,#mark84897 p{color:#333;}#mark84897 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:monospace;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark84897 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark84897 :root{--mermaid-font-family:monospace;}f_4f_3f_2f_2f_1f_1f_0f_1f_0time complexity = Given every function will request two functions, the time complexity = O(1 + 2 + 4 + ... + 2^(n-1)) = O(2^n - 1) = O(2^n)space complexity = The data we need to store is f(1), f(2), ... f(n), meaning the space complexity = O(n)Product of A and Bcodefunction product(a, b) { let sum = 0 for (i = 0; i < b; i ++) { sum += a } return sum}Time complexity: it will add a for b times, so the time complexity will be O(b)b^acodefunction power(a, b) { let result = 1 for (i = 0; i < a; i++) { result * b } }Time complexity: it will time result a times, so the time complexity is O(a).A % Bcodefunction mod(a, b) { let result = a while (result >= b) { result - b } return result}Time complexity: it will calculate (A/B) times, so the time complexity is O(A/B).Referencecracking the coding interviewmjx-container[jax=\"SVG\"] { direction: ltr;}mjx-container[jax=\"SVG\"] > svg { overflow: visible; min-height: 1px; min-width: 1px;}mjx-container[jax=\"SVG\"] > svg a { fill: blue; stroke: blue;}mjx-container[jax=\"SVG\"][display=\"true\"] { display: block; text-align: center; margin: 1em 0;}mjx-container[jax=\"SVG\"][display=\"true\"][width=\"full\"] { display: flex;}mjx-container[jax=\"SVG\"][justify=\"left\"] { text-align: left;}mjx-container[jax=\"SVG\"][justify=\"right\"] { text-align: right;}g[data-mml-node=\"merror\"] > g { fill: red; stroke: red;}g[data-mml-node=\"merror\"] > rect[data-background] { fill: yellow; stroke: none;}g[data-mml-node=\"mtable\"] > line[data-line], svg[data-table] > g > line[data-line] { stroke-width: 70px; fill: none;}g[data-mml-node=\"mtable\"] > rect[data-frame], svg[data-table] > g > rect[data-frame] { stroke-width: 70px; fill: none;}g[data-mml-node=\"mtable\"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed { stroke-dasharray: 140;}g[data-mml-node=\"mtable\"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted { stroke-linecap: round; stroke-dasharray: 0,140;}g[data-mml-node=\"mtable\"] > g > svg { overflow: visible;}[jax=\"SVG\"] mjx-tool { display: inline-block; position: relative; width: 0; height: 0;}[jax=\"SVG\"] mjx-tool > mjx-tip { position: absolute; top: 0; left: 0;}mjx-tool > mjx-tip { display: inline-block; padding: .2em; border: 1px solid #888; font-size: 70%; background-color: #F8F8F8; color: black; box-shadow: 2px 2px 5px #AAAAAA;}g[data-mml-node=\"maction\"][data-toggle] { cursor: pointer;}mjx-status { display: block; position: fixed; left: 1em; bottom: 1em; min-width: 25%; padding: .2em .4em; border: 1px solid #888; font-size: 90%; background-color: #F8F8F8; color: black;}foreignObject[data-mjx-xml] { font-family: initial; line-height: normal; overflow: visible;}mjx-container[jax=\"SVG\"] path[data-c], mjx-container[jax=\"SVG\"] use[data-c] { stroke-width: 3;}","url":"/blog/software/dsa/complexity"},{"title":"(dsa) Main","content":"(dsa) MainPurposeTo [solve problem] in a more efficient way, making no more space to improve both the [time complexity and space complexity].ConceptWe can decompose all the programming logics into four actions: create, read, update, delete. The time complexity of CRUD an element in specific data structure is as follow: (The order is based on popularity)CreateReadUpdateDeleteArraysO(1) - O(n)O(1)O(1)O(1) - O(n)Linked ListsO(1)O(n)O(n)O(n)Hash TablesO(1)O(1)O(1)O(1)TreesO(1)O(n)O(n)O(n)GraphsO(1)O(v+e)O(1)O(v+e)StacksO(1)O(1)O(1)O(1)QueuesO(1)O(1)O(n)O(1)HeapsO(1)O(n)O(log n)O(log n)TriesO(n)O(n)O(n)O(n)Explanation:\"n\" refers to the number of total elements in the data structure currently\"v\" refers to the number of vertices (nodes) in the graph\"e\" refers to the number of edges in the graphPlease refer to following sections to see whyExampleArrayIt is a data structure in programming that stores a collection of elements. These elements are stored in contiguous memory locations, and each element can be accessed using an index or a subscript. Please refer to array for more information.Linked listA linked list is a linear data structure where elements are stored in a sequence, and each element is linked to its next element using pointers or references. It consists of a series of nodes, where each node contains a data element and a reference to the next node in the sequence. For more information, please refer to linked list.Hash TableA hash table is a data structure that provides fast access to values based on a key. It uses a hash function to map keys to indices in an array, allowing for constant-time access to values, making it an efficient choice for many types of applications. For more information, please refer to hash table.TreeA tree is a hierarchical data structure with nodes connected by edges, and a single root node at the top. It is used in computer science to represent data with a hierarchical structure, and various algorithms have been developed to manipulate and process tree structures efficiently. For more information, please refer to tree.GraphA graph is a visual representation of data that shows the relationship between different variables. It consists of nodes or vertices connected by edges or links that illustrate the connections or interactions between them. For more information, please refer to graph.StackA stack is an abstract data type that represents a collection of elements in a particular order. It follows the Last-In-First-Out (LIFO) principle, where the last element added to the stack will be the first one to be removed. For more information, please refer to stack.QueueA queue is a linear data structure that follows the First-In-First-Out (FIFO) principle, where the first element added to the queue is the first element to be removed. It is commonly used in computer science and everyday life for organizing tasks or processing requests in a sequential manner. For more information, please refer to queue.HeapA heap is a specialized tree-based data structure that satisfies the heap property, where the value of each node is greater than or equal to (in a max heap) or less than or equal to (in a min heap) the values of its child nodes. Heaps are commonly used for efficient priority queue operations and serve as a foundation for algorithms like heap sort and finding the kth largest/smallest element. For more information, please refer to heap.TriesA trie, also known as a prefix tree, is a data structure used to store and search for strings efficiently. It organizes strings by their common prefixes, allowing for fast retrieval and insertion operations. For more information, please refer to tries.Dynamic ProgrammingDynamic programming is often applied to problems with recursive sequences of sub-problems, such as graph shortest path and longest common subsequence, by solving each subproblem only once and efficiently addressing large-scale optimization problems. The concept involves breaking down optimization problems into smaller sub-problems, storing and reusing their solutions to avoid redundant computations. For more information, please refer to dynamic programming.SortingSorting is a fundamental operation in computer science that involves arranging a collection of elements in a specific order. It plays a crucial role in various applications, such as searching, data analysis, and maintaining data integrity, by providing an organized and easily accessible representation of the data. For more information, please refer to sorting.referencecracking the coding interviewThe top data structures you should know for your next coding interview","url":"/blog/software/dsa/main"},{"title":"(ood) Main","content":"(ood) MainPurposeObject oriented design is used to structure and organize code by modeling real-world entities as objects, facilitating modularity, reusability, and easier maintenance in software development.ConceptStep 1: Conduct system designFor example, we want to design a library system. After [system design], we should obtain the objects.Step 2: Identify the objectsBased on the requirements, identify the main objects or entities that will be part of the system. These objects should represent real-world entities or concepts relevant to the problem domain.Book: Represents a book with attributes such as title, author, ISBN, and availability statusMember: Represents a library member with attributes such as name, membership number, and a list of borrowed booksLibrary: Represents the library itself, responsible for managing books, members, and their interactionsStep 3: Define class hierarchies and relationshipsEstablish relationships between the identified objects by defining class hierarchies, associations, aggregations, or compositions. This step involves organizing objects into classes and determining how they interact and collaborate with each other.Book has many BorrowerBorrower inherited from MemberLibrary has many MemberLibrary has many BookBorrower has any BookStep 4: Define object behaviors and methodsInvolves identifying the attributes (data) and methods (functions) associated with each class. Methods define the operations or actions that can be performed by the objects.Book class may have methods like checkAvailability() to check if the book is available and reserve() to reserve a book for a member.Member class may have methods like borrowBook() to borrow a book and returnBook() to return a book.Library class may have methods like addBook() to add a book to the library, trackAvailability() to track the availability of books, issueBook() to issue a book to a member, and returnBook() to process the return of a book.Step 5: Refine the designReview and refine the design by considering principles such as encapsulation, inheritance, polymorphism, and other object-oriented design principles. Ensure that the design is modular, extensible, and adheres to best practices.Step 6: Implement the designTranslate the design into actual code using a programming language. Follow the design principles and guidelines to implement the classes, their relationships, and their behaviors. Please refer to object oriented programming and SOLID.Step 7: Test and iterateTest the implemented system to verify its correctness, functionality, and performance. Iterate as necessary to fix any bugs, address design issues, and improve the overall quality of the system.ExamplesDeck of CardsQuestion: Design the data structures for a generic deck of cards. Explain how you would subclass the data structures to implement blackjack.I will design the deck:class Deck { constructor(sequence = null) { if(!sequence) { const newCards = Array.from(Array(13).keys(), x => x + 1) this.cards = newCards.concat(newCards, newCards, newCards) } else { this.cards = sequence } }}module.exports = Deckin accordance with,codeclass Dealer { constructor() { this.cards = [] }}class Player { constructor() { this.cards = [] } hit() {} stand() {}} class BlackJack { // only one player // reshuffle after every round // dealer must hit if total <= 16 // dealer must hold if total > 16 constructor(deck) { // 8, 11, 3, 6, 10, 1 this.deck = deck this.player = new Player() this.dealer = new Dealer() this.player.cards.push(this.deck.cards.shift()) this.dealer.cards.push(this.deck.cards.shift()) this.player.cards.push(this.deck.cards.shift()) this.dealer.cards.push(this.deck.cards.shift()) } perform(playerMove) { if (playerMove === 'hit') { this._performPlayerHit() this._performDealer() } else { this._performPlayerStand() this._performDealer() } return this._result() } _performPlayerHit() { this.player.cards.push(this.deck.cards.shift()) } _performPlayerStand() { return } _performDealer() { const dealerScore = this._scoreCalculator(this.dealer.cards) if(dealerScore <= 16) { this._performDealerHit() } else { this._performDealerStand() } } _performDealerHit() { this.dealer.cards.push(this.deck.cards.shift()) } _performDealerStand() { return } _result() { const playerScore = this._scoreCalculator(this.player.cards) const dealerScore = this._scoreCalculator(this.dealer.cards) if(playerScore > dealerScore) { return 'wins' } else if(playerScore < dealerScore) { return 'lose' } else { return 'tie' } } _scoreCalculator(cards) { const score = cards.reduce((accumulator, currentValue) => { if(currentValue >= 10) { return accumulator + 10 } else { return accumulator + currentValue } }, 0) return score }}module.exports = BlackJacktestBlackJack = require('./blackjack.js')Deck = require('./deck.js')describe('BlackJack', () => { describe('8, 11, 3, 6, 10, 1', () => { let deck let game beforeEach(() => { deck = new Deck([8, 11, 3, 6, 10, 1]) game = new BlackJack(deck) // Dealer: 11, 6 // Player: 8, 3 }) describe('Player hit', () => { test('should let dealer stand', () => { expect(game.dealer.cards.length).toEqual(2) }) test('should announce player wins', () => { expect(game.perform('hit')).toEqual('wins') }) }) describe('Player stand', () => { test('should let dealer stand', () => { expect(game.dealer.cards.length).toEqual(2) }) test('should announce player lose', () => { expect(game.perform('stand')).toEqual('lose') }) }) })// test('[9, 2, 7, 4, 11, 8]', () => {// beforeEach(() => {// let deck = new Deck([9, 2, 7, 4, 11, 8])// let game = new BlackJack(deck)// })// // Dealer: 2, 4// // Player: 9, 7// it('should let dealer hit', () => { // })// test('Player hit', () => {// it('should announce player lose', () => {// })// })// test('Player hold', () => {// it('should announce dealer lose', () => { // })// })// })})TODOCall CenterJukeboxJukeboxOnline Book ReaderJigsawOthelloCircular ArrayMinesweeperFile SystemHash TableReferenceChatGPT","url":"/blog/software/ood/main"},{"title":"(system-design) Main","content":"(system-design) MainPurposeSystem design is essential to ensure that a software system is well-structured, efficient, and capable of meeting its intended goals and requirements, providing a roadmap for the development process and enabling successful implementation.ConceptDesign Whole SystemFor example, let's design TinyURLStep 1 Scope the ProblemAsk lots of questions to define user stories and get the requirements. After the questions, we should know the requirements:Shortening a URL to a TinyURLAnalytics for a URLRetrieving the URL associated with a TinyURLUser accounts and link managementStep 2: Make Reasonable AssumptionsBased on step 1, given each requirement, we need to think about Feasibility, Impact Analysis, Scalability and ExtensibilityFeasibilitytechnical constraintsresource availabilitytime constraintsImpact Analysisfunctionalityperformancesecurityuser experienceScalability and Extensibilityincreasing user loadadditional featuresintegration with new technologiesStep 3: Draw the Major Components (on whiteboard)FrontendUser Interface: The UI component serves as the visual gateway for users to interact with the system, enabling them to input URLs, access analytics, manage links, and perform various actions through pages, forms, buttons, and other interface elements.URL Shortening Form: The URL Shortening Form component captures user-inputted long URLs, validating and handling potential errors, before forwarding the data to the backend for processing.Analytics Dashboard: The analytics dashboard component presents visually appealing and user-friendly statistics and insights, including click counts, referral sources, and geographical data, for the shortened URLs.User Account Management: The User Account Management component facilitates user registration, login, and account management functionalities, providing forms for actions such as registration, login, password reset, and profile management.BackendAPI: The backend exposes APIs that define the contract for request and response formats, allowing seamless communication and interaction between the frontend and backend components of the system.URL Shortening Service: The URL Shortening Service component generates unique and concise aliases (TinyURLs) for long URLs received from the frontend, utilizing algorithms or mapping mechanisms to create and store mappings between the TinyURLs and their corresponding original URLs.Analytics Engine: The Analytics Engine component processes and aggregates data on URL clicks, referral sources, and other metrics, storing the information to generate reports and provide valuable analytics insights, while the User Management System component handles user account management, authentication, authorization, and tasks such as registration, login, password management, and link ownership.Database: The Database component efficiently stores and retrieves the required data for the system, encompassing tables or collections that hold information such as URLs, analytics data, user accounts, and link management.External Services Integration: The backend may need to integrate with external services, such as geo-location services for gathering geographical data or third-party authentication services for user account management.Step 4: Identify the Key IssuesBased on information in step 2 and step 3, determine the priorities and know which bottleneck should be solved first; for example, the frontend and backend for user to input URL has the highest priority and the boss actually care security more than performance, so although we know cache the urls on frontend will be faster, we still let user to query them because we do not want to store the urls on frontend for hackers.Step 5: Redesign for the Key IssuesAfter step 4, we should adjust our design; for example, some components take too much time but is not that important, so we can remove it currently from the major components.Step 6: Choose the right frameworksIf you do not know which frontend, backend, database to choose, just choose the most popular one.Step 7: Start to codeOk, based on above design, we now should have components, user interface, URL shortening, analytics, user account management, APIs, services, database, and external integrations and we can start to think about the design patterns for them.Any user interface related frontend and backend, we should use [MVC structure]. That is, we break Create, Read, Update, Destroy (CRUD) of links and CRUD of users into [RESTful] design, which is going to return us methods mapping GET (Read), POST (Create), PUT (Update), DELETE (Destroy); for example, in [rails, we have 7 methods].Now we can successfully CRUD the data. The next step is to return desired services for usersURL shortening service should use singleton pattern to avoid multiple shortened URL to be created for one URL.Analytics service should use observer or strategy patternIf the calculations take time, we can use observer pattern to trigger analytics data calculations right after key information updates. But I think it will not be the case in this system.If we need multiple same key statistics with some difference on different environments, we may need strategy pattern; for example, users all care about the click rate of tinyURL but definition of denominator and numerator may be the same of different on different components. Then we can initiate multiple services with the combinations of the methods to calculate denominator and numerator.User management service should use decorator pattern to return different data given the type of users; for example, we may need to examine the authentication of users before they use an API. Then we can have decorator to decorate the ability based on the identity of the users.External service should use adapter pattern to connect different data source with same method; for example, we know google and facebook both provide statistics and we can write a method to deal with these two different APIs. Then although both use connect method, based on the adaptor, we can connect the APIs successfully and do the next steps.For more information, please refer to design pattern.Design An AlgorithmSometimes we do not need to re-design a system but we want to solve an algorithm.Step 1: Ask Questions, try to find out the input and output of this function.Step 2: Make Believe, assume there is no limitations first, so that we can find the general solutions.Step 3: Get Real, try to write down pseudocode first and even start compose the functions.Step 4: Solve Problems, during step 3, there will be more problems occurs and keep iterating.Normal SolutionsDesign for scalabilityThere are two ways of scalability; one is horizontal, the other is vertical. For more information, please refer to scalability.TODOScalingLoad balancerDenormalizationNoSQLShardingCachingBackground jobNetworking MetricsMapReduceOther ConsiderationsDistribute SystemsA distributed system refers to a network of interconnected computers that work together to solve a common problem or perform a coordinated task. It involves the distribution of resources, data, and processing across multiple machines, enabling collaboration and scalability beyond the capabilities of a single system. For more information, please refer to [distributed systems].Real-time operating systemsReal-time systems, scheduling, and response times.TODOFailuresConcept: Systems are prone to failures, and it's crucial to plan for them. Identify potential points of failure in your system and design appropriate measures to handle them.ExampleRedundancyFault toleranceError handlingDisaster recovery strategies.Availability and ReliabilityConcept: Availability refers to the percentage of time a system is operational and accessible to users. Reliability is the probability that the system will remain operational over a specified period.ExampleLoad balancingClusteringMonitoringAutomated failoverRead-heavy vs. Write-heavyConcept: Depending on whether your system is more read-heavy or write-heavy, you can design strategies such as queuing writes for write-intensive applications or utilizing caching mechanisms for read-intensive applications to optimize performance and mitigate potential failures.Read-heavy maps to distributed systemWrite-heavy maps to real-time operation systemSecuritySecurity threats pose significant risks to a system. Identify potential security vulnerabilities and design appropriate security measures to protect your system. This can include authentication mechanisms, access controls, encryption, input validation, and robust error handling to prevent attacks like injection, cross-site scripting, and data breaches.Referencecracking the coding interviewchatGPT","url":"/blog/software/system-design/main"},{"title":"(os) Main","content":"(os) MainPurposeUnderstanding low-level computer operations is essential for computer engineering, software development, and information technology professionals to develop efficient software applications, manage computer systems, and enhance security against external threats.ConceptOverviewOperating System serves as the communicator between computer hardware and computer software applications.#mark28252{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark28252 .error-icon{fill:#552222;}#mark28252 .error-text{fill:#552222;stroke:#552222;}#mark28252 .edge-thickness-normal{stroke-width:2px;}#mark28252 .edge-thickness-thick{stroke-width:3.5px;}#mark28252 .edge-pattern-solid{stroke-dasharray:0;}#mark28252 .edge-pattern-dashed{stroke-dasharray:3;}#mark28252 .edge-pattern-dotted{stroke-dasharray:2;}#mark28252 .marker{fill:#333333;stroke:#333333;}#mark28252 .marker.cross{stroke:#333333;}#mark28252 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark28252 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark28252 .cluster-label text{fill:#333;}#mark28252 .cluster-label span,#mark28252 p{color:#333;}#mark28252 .label text,#mark28252 span,#mark28252 p{fill:#333;color:#333;}#mark28252 .node rect,#mark28252 .node circle,#mark28252 .node ellipse,#mark28252 .node polygon,#mark28252 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark28252 .flowchart-label text{text-anchor:middle;}#mark28252 .node .label{text-align:center;}#mark28252 .node.clickable{cursor:pointer;}#mark28252 .arrowheadPath{fill:#333333;}#mark28252 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark28252 .flowchart-link{stroke:#333333;fill:none;}#mark28252 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark28252 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark28252 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark28252 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark28252 .cluster text{fill:#333;}#mark28252 .cluster span,#mark28252 p{color:#333;}#mark28252 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark28252 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark28252 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}operation_systemcreatedecomposed bycommunicates withinteracts withperforms I/O throughmanagemanageprovidesfacilitatesfacilitatesprocess managementJobKernelFile SystemDevice Driversmemory managementSystem CallsConcurrency and SynchronizationUser InterfaceuserapplicationhardwareWhen a job or task is initiated from an application, the operating system's process management component handles the creation of a new process, allocating necessary resources through the kernel, managing memory and CPU usage, coordinating I/O operations through device drivers, and providing an interface for user interaction, all while ensuring the overall stability and efficiency of the system.memory managementGiven processes in a computer, memory management checks how much memory to be allocated, what time to allocate the memory, and update the status of memory once some memory gets freed or unallocated. For more information, please refer to process management.device managementIn order to handle physical and virtual devices, device controller born in OS. Physical device includes all Input/Output devices and virtual devices mimics physical device in software, serving as device in system, making system to believe a particular hardware exists.file managementRecorded on secondary or non-volatile storage such as optical disks and used as medium for input and output of data.securityTo prevent threats and attacks, several ways: regular OS patch updates, antivirus engines and software, firewall, stratification of authorization.performance monitoringTo optimize the OS, we need logs from performance monitoring for further optimization.job accountingFor tracking the time and resources used by various jobs and users.error detectingGiven noise in transmission of data, error detecting ensures reliable delivery of data by patching the data on time.coordinationGiven lots of program at the sametime, OS corrdination serves to schedule these programs.ExampleIn this section, let's take a look at the above functions in operating systems and explore them with following steps:user click an app on the computer UIthe app start to run and it need some computationthe data flow to operation systemoperation system call hardware (CPU, RAM, I/O) to compute itdata sent back to OSOS send data back to appuser get what they want in UITODOmac OSReferenceChatGPT","url":"/blog/software/os/main"},{"title":"(database) Main","content":"(database) MainPurposeDatabases provide a structured and efficient way to store, manage, and retrieve large amounts of data.ConceptLet's consider an example of building a database system for a blog. The steps:DesignDefine problem: I need a way to manage users. There will be two roles, users and admins. Some articles are only visible to login users amd some features are only available to admins.Identify entities or relationships: User. If there is relationship between these entities, we use ERD to visualize it.Choose a suitable database management system (DBMS). Consider options based on the requirements, data structure, and scalability needs.Relational: MySQLNoSQL: [MongoDB]Design the database schemaConvert the ERD into a logical data modelDefine tables: UserDefine constraints to each columnFrameworkGiven we have chosen framework such as node or rails. We use framework to do the following tasks:Config databaseMigrate SchemaDevelop CRUD API layers with validations, callbacks, and authenticationGenerate sample data scriptWrite tests to verify the functionality of CRUDDeploy the databaseMaintain and optimize the databaseContinuously improve the database with user feedbacksOptimizations such as caching, [denormalization] strategies, partitioning, sharding","url":"/blog/software/database/main"},{"title":"(tdd) Main","content":"(tdd) MainPurposeTDD reduces bugs and increase the quality of code, making software to be more maintainable and understandable. With no test, there would be more manual test in the future and it would be hard to update the version.ConceptTDD is a software development process by writing test first and then keeping testing the software until all required function developed. The steps:Turn business logic into specificationsDecompose specifications into functions (MVC)Define all desired input and output of each functionWrite test first for every functionCompose codebase to realize business logic, given the testsAAA principle (Arrange -> Act -> Assert)The basic principle to build spec is AAA principle.arrange: describe the environment before action beginact: execute the unit function that we want to testassert: check whether the result is what we wantAAA principle maps Jestdescribe('Test sum', () => { test('adds 1 + 2 to equal 3', () => { // Arrange const a = 1; const b = 2; // Act const result = a + b; // Assert expect(result).toBe(3); });});JestAAA principle maps RspecRSpec.describe \"the_summary\", type: :feature do context \"when acting on something\" do it \"should have an assertion\" do # Arrange # Set up any necessary context or variables here # Act result = \"act\" # Assert expect(result).to eq(\"expected result\") end endendRSpecCoverageUnit and integration tests should touch every line of code. Coverage reveals the percentage of code has been tested or the percentage of code may not be required.The reasonable coverage rate: 80%In rails, we use gem simplecovIn express,In react,ExampleFor example, a woodcutter go into a forest (arrange the environment) -> the woodcutter use the axe to cut the wood (act the function) -> and the woodcutter should get the woods (assert the result). If the woodcutter does not like the result, woodcutter should modify the act.RspecInitmkdir woodcuttercd woodcuttergem install rspecFilesmkdir woodcuttermkdir spectouch woodcutter.rb # in woodcutter/touch woodcutter_spec.rb # in spec/Specrequire_relative '../woodcutter'describe Woodcutter do let(:in_right_place) let(:init_num_of_woods) let(:woodcutter) { Woodcutter.new(in_right_place, init_num_of_woods) } before do # arrange in_right_place = true init_num_of_woods = 0 end it \"should work\" do woodcutter.cut # act expect(woodcutter.woods).to be 1 # assert endendBuildExecute specrspec woodcutter_spec.rbGiven the errors, build the featureclass Woodcutter def initialize(in_right_place = true, init_num_of_woods = 0) @woods = init_num_of_woods end def cut @woods += 1 end def woods @woods endendReferenceLearn TDD in Rails Learn TDDRuby on Rails 實戰聖經https://en.wikipedia.org/wiki/Test-driven_developmentHello Testing - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天What are the different kinds of Rails tests and when should I use each? - Code with Jasonteamcapybara/capybararspec/rspec-rails","url":"/blog/software/tdd/main"},{"title":"","content":"","url":"/blog/test"},{"title":"(dsa) Array","content":"(dsa) ArrayPurposeArray is one of the most fundamental and widely used data structures, offering efficient storage and retrieval, simple implementation, versatility, efficiency, and being widely used in many fields of computer science.ConceptStringBecause the algorithm of string is just like arrayList, so I will put string algorithm in arrayList.Array vs ArrayListAn array is a fixed-size data structure, while an ArrayList is a dynamic, resizable data structure.Basic FormIn javascript,Example[1, 2, 3, 4]Data: A collection of elements of the same data type, arranged in a contiguous block of memoryTime complexityCreate an element: O(1) to O(N)Inserting an element at the end of an arrayList has O(1) but may be O(N) if we need to resize the arrayListInserting an element at the beginning of an arrayList has O(N) because we need to shift all the elementsRead an element: O(1)Given an index i, the read operation in an ArrayList retrieves the element at that index in constant time, regardless of the size of the ArrayList because the addresses of the items are stored continuously in memory, which means it can access other addresses by quick calculation of memory_address = base_address + (index * element_size).Update an element: O(1)Given an index i and a new value v, the update operation in an ArrayList replaces the element at index i with the new value v in constant time, regardless of the size of the ArrayList.Delete an element: O(1) to O(N)In the worst case, where n is the number of elements in the ArrayList because deleting an element requires shifting all subsequent elements one position to the left to fill the gap left by the deleted element. Deleting the last element in an ArrayList has a time complexity of O(1) on average because it can be done by simply updating the size of the ArrayList.Is Unique (string)BUDQuestion: Implement an algorithm to determine if a string has all unique charactersBrute force:s = 'example'function charactersIsUnique(s) { if(typeof s != 'string') { return 'type error'; } for (var i = 0; i < s.length; i++) { for (var j = 0; j < s.length; i++) { if (s[i] == s[j]) { return 'not unique' } else { continue; } } } return 'unique'}charactersIsUnique(s)The above code is brute force solution with edge case considered. The time complexity = unncessary work: actually, for any character, we only need to compare the characters on their right-hand side, so we can rewrite it as follow:s = 'example'function charactersIsUnique(s) { if(typeof s != 'string') { return 'type error' } for (var i = 0; i < s.length; i++) { for (var j = i+1; j < s.length; i++) { if (s[i] == s[j]) { return 'not unique' } else { continue; } } } return 'unique'}charactersIsUnique(s)Then the number of times will be ; however, the time complexity is still Bottleneck: the place with highest time complexity is the nested for loops, so we should try to use only one for loop. What we can do here is use a hash as follow:string = 'example'function charactersIsUnique(s) { object = {} if(typeof s != 'string') { return 'wrong type' } for (var i = 0; i < s.length; i++) { if(object.hasOwnProperty(s[i])) { return 'not unique' } else { object[s[i]] = 1 } } return 'unique'}charactersIsUnique(s)Then the time complexity reduces to real world exampleLet's say we have a stack of test papers and teacher wants to find the students with same name to make sure there is no mistake when we record the scores. What the teacher may do aretake notes of all the names walked through and check it first every next student comes (like the example above)sort the papers with the order of names and it is easy to find out duplicate names. (check the sorting section) But actually there is no sorting method lower or equal to O(N)general solutionI think the solution above is general enoughstack upIs there a recursive solution? seems notbest time complexityWe at least need to walk through all letters, so it is at least O(N). And we actually only need to walk through once.Testdescribe('Is Unique', () => { describe('s = example', () => { let s = 'example' expect(charactersIsUnique(s)).toEql(false) }) describe('s = fast', () => { let s = 'fast' expect(charactersIsUnique(s)).toEql(true) })})Check Permutation (String)Question: Given two strings, write a method to decide if one is a permutation of the other.Brute force:function checkPermutation(string1, string2) { for (var i = 0; i < string1.length; i++) { target = string1[i] for (var i = 0; i < string2.length; i++) { if (string2[i] == target) { remove string2[i] from string2 } } } if len(string2[i]) == 0 { return true } else { return false }}Unnecessary work: noneBottleneck: the place with highest complexity is the nested for loop. To solve it, my first though is hash tablefunction checkPermutation(string1, string2) { hash_table = {} for (var i = 0; i < string1.length; i++) { if hash_table[string[i]] = null { hash_table[string[i]] = 1 } else { hash_table[string[i]] += 1 } } for (var i = 0; i < string2.length; i++) { hash_table[string[i]] -= 1 } if hash_table.values = 0 { return true } else { return false }}Given the length of string1 is A and length of string2 is B, the complexity is .We also can sort them first and compare the first n elements of characters.Duplicate Work: noneReal world example: noneMore general solution: noneBest time complexity: We need to at least check all the letters, so the best time complexity is Stack up: noneTestcheckPermutation = require('../examples/check_permutation.js')describe('checkPermutation', () => { test('s1 = wqer, s2 = rewq', () => { expect(checkPermutation('wqer', 'rewq')).toEqual(true) }) test('s1 = asfd, s2 = rewq', () => { expect(checkPermutation('asdf', 'rewq')).toEqual(false) })})resultfunction checkPermutation(string1, string2) { const hash_table = {} for (let i = 0; i < string1.length; i++) { if(hash_table[string1[i]] = null) { hash_table[string1[i]] = 1 } else { hash_table[string1[i]] += 1 } } for (let i = 0; i < string2.length; i++) { hash_table[string2[i]] -= 1 } return Object.values(hash_table).every(element => element === 0)}Binary Searchfunction binarySearch(array, target) { let low = 0; let high = array.length - 1; while (low <= high) { const mid = Math.floor((low + high) / 2); const midValue = array[mid]; if (midValue === target) { return mid; // Target found, return the index } else if (midValue < target) { low = mid + 1; // Target is in the right half of the remaining array } else { high = mid - 1; // Target is in the left half of the remaining array } } return -1; // Target not found}// Usage example:const sortedArray = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91];const targetValue = 23;const resultIndex = binarySearch(sortedArray, targetValue);if (resultIndex !== -1) { console.log(`Target value ${targetValue} found at index ${resultIndex}.`);} else { console.log(`Target value ${targetValue} not found in the array.`);}URLifyQuestion: Write a method to replace all spaces in a string with '%20'. You may assume that the string has sufficient space at the end to hold the additional characters, and that you are given the \"true\" length of the string.Example:Input: \"Mr John Smith \", 1313 is the length of the original string \"Mr John Smith\" excluding any trailing white spacesOutput: \"Mr%20John%20Smith\"brute force:function URLify(string, length) { result = '' for (var i = 0; i < length; i ++) { if (i + 1 === length) { break } else if (string[i] === ' ') { result += '%20' } else { result += string[i] } }}The time complexity = = unnecessary work: On higher point of view, the loop to calculate numberOfNotSpace must be more unnecessary and the truth is we only need to break the loop if the loop meets space twice as follow:function URLify(string, length) { lastLetter = '' for (var i = 0; i < string.length; i++) { lastLetter = string[i] result = '' if (string[i] != ' ') { result += string[i] } else { result += '%20' if lasterLetter == '' { break } } }}Then the time complexity = .Palindrome PermutationQuestion: Given a string, write a function to check if it is a permutation of a palindrome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is a rearrangement of letters. The palindrome does not need to be limited to just dictionary words.brute force:function Palindrome(string) { diatonic = '' for (var i = 0; i < string.length; i++) { if (string[i] != ' ') { diatonic += string[i].lowercase } } chromatic = '' for (var i = array.length; i--;) { if (string[i] != ' ') { chromatic += string[i].lowercase } } if diatonic == chromatic { return true } else { return false }}The time complexity = = unnecessary work: actually, if it is Palindrome, then the first half of the first loop is just like the last half of the second loop, so we may can optimize it withfunction Palindrome(string) { for (var i = 0; i < string.length; i++) { if (string[i] == ' ') { continue } elsif (string[i] == string[-i]) { // the correct way to call string[-i] is string.charAt(string.length - (i+1)) continue } else { return false } }}Then the time complexity = . We can also try to break it at the point of middle, then the time complexity = One AwayQuestion: There are three types of edits that can be performed on strings: insert a character, remove a character, or replace a character. Given two strings, write a function to check if they are one edit (or zero edits) away.Example (all edge case included)paie, pie -> truepaies, paie -> truepaie, baie -> truepaie, bake -> falseCodefunction oneAway (s1, s2) { let match = {} const concatString = s1 + s2 for (let i = 0; i < concatString.length; i++) { if (match[concatString[i]] === undefined) { match[concatString[i]] = i } else { match[concatString[i]] -= i } } let noMatch = 0 let misMatch = 0 let positionDistance = 0 for (const key in match) { const value = match[key] if (value > 0) { noMatch += 1 } if (value < 0) { positionDistance = value if (positionDistance !== value) { misMatch += 1 } } } if (noMatch > 1 || misMatch > 1) { return false } else { return true }}module.exports = oneAwayTestdescribe('One Away', () => { test('paie, pie', () => { expect(OneAway('paie', 'pie')).toEqual(true) }) test('paies, paie', () => { expect(OneAway('paies', 'paie')).toEqual(true) }) test('paie, baie', () => { expect(OneAway('paie', 'baie')).toEqual(true) }) test('paie, bake', () => { expect(OneAway('paie', 'bake')).toEqual(true) })})Time Complexity = O(m + n) and GPT said the minimum is O(min(m, n))There is a technique: while (i < s1.length && j < s2.length), which can iterate two array at the same time.Process: Question -> add questions for edge cases for full examples -> guess best time complexity -> code -> testString CompressionQuestion: Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2b1c5a3, If the \"compressed\" string would not become smaller than the original string, your method should return the original string. You can assume the string has only uppercase and lowercase letters (a - z).Examplea => a1 (X)aaab => a3b1 (X)aabbcc => a2b2c2 (X)abbcc => a1bbcc (X)aa => a2 (X)aaa => a3 (V)aabcccccaaa => a2b1c5a3 (V)I believe I can just compare the length after the operation.Codefunction stringCompression(string) { let compressed = ''; let count = 1; for (let i = 0; i < string.length; i++) { if (string[i] === string[i + 1]) { // the key is string[i + 1] will return undefined count++; } else { compressed += string[i] + count; count = 1; } } return compressed.length < string.length ? compressed : string;}module.exports = stringCompressionTestdescribe('stringCompression', () => { test(stringCompression('aabcccccaaa')).toEqual('a2b1c5a3') test(stringCompression('a')).toEqual('a')})Rotate MatrixQuestion: Given an image represented by an NxN matrix, where each pixel in the image is 4bytes, write a method to rotate the image by 90 degrees. Can you do this in place?ExampleThe possible input would beinput = [ [1111, 2222], [3333, 4444],]And the output of the input aboveoutput = [ [3333, 1111], [4444, 2222]]Time complexity: since we must need to walk through all the elements, the time complexity will be at least O(N^2)Codefunction rotateMatrix(matrix) { result = [] for(let i = matrix.length - 1; i >= 0; i--) { if(i == matrix.length - 1) { for(let j = 0; j < matrix[i].length; j++) { result.push([matrix[i][j]]) } } else { for(let j = 0; j < matrix[i].length; j ++) { result[j].push(matrix[i][j]) } } } return result}Testdescribe('rotate matrix', () => { let input = [ [1111, 2222], [3333, 4444], ] test('#', () => { expect(rotateMatrix(input)).toEqual([ [3333, 1111], [4444, 2222] ]) })})Zero MatrixQuestion: Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.Example:1:// input[ [0, 1]]// output[ [0, 0]]2:// input[ [0], [1]]// output[ [0], [0]]Time complexity: I believe I at least need to traverse all the elements, so the time complexity is at least O(mn)Codefunction zeroMatrix(matrix) { rowIndex = [] // M rows columnIndex = [] // N columns for(let i = 0; i < matrix.length; i++) { // m for(let j = 0; j < matrix.length; j++) { // n if(matrix[i][j] === 0) { rowIndex.push(i) columnIndex.push(j) } } } for(let i = 0; i < matrix.length; i++) { for(let j = 0; j < columnIndex.length; j++) { matrix[i][columnIndex[j]] = 0 } } for(let i = 0; i < rowIndex.length; i++) { for(let j = 0; j < matrix.length; j++) { matrix[rowIndex[i]][j] = 0 } } return matrix}Testdescribe('zero matrix', () => { test('#', () => { let matrix = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], ] expect(zeroMatrix(matrix)).toEqual([ [0, 0, 0], [0, 4, 5], [0, 7, 8], ]) })})TODOString RotationWhat?Real-world problem that uses an arrayList data structure and algorithmI want to create a search bar to search keyword on my websiteI need to use array to store the postsconst posts = [ { title: \"My first post\", content: \"This is my first post on the platform!\", author: \"Alice\" }, { title: \"Cool photo\", content: \"Check out this cool photo I took on my vacation.\", author: \"Bob\" }, { title: \"Important announcement\", content: \"We have an important announcement to make...\", author: \"Admin\" }];Implement the search functionfunction searchPosts(keyword) { const results = []; for (let i = 0; i < posts.length; i++) { const post = posts[i]; if (post.title.includes(keyword) || post.content.includes(keyword)) { results.push(post); } } return results;}const results = searchPosts(\"vacation\");console.log(results);Referencecracking the coding interviewmjx-container[jax=\"SVG\"] { direction: ltr;}mjx-container[jax=\"SVG\"] > svg { overflow: visible; min-height: 1px; min-width: 1px;}mjx-container[jax=\"SVG\"] > svg a { fill: blue; stroke: blue;}mjx-container[jax=\"SVG\"][display=\"true\"] { display: block; text-align: center; margin: 1em 0;}mjx-container[jax=\"SVG\"][display=\"true\"][width=\"full\"] { display: flex;}mjx-container[jax=\"SVG\"][justify=\"left\"] { text-align: left;}mjx-container[jax=\"SVG\"][justify=\"right\"] { text-align: right;}g[data-mml-node=\"merror\"] > g { fill: red; stroke: red;}g[data-mml-node=\"merror\"] > rect[data-background] { fill: yellow; stroke: none;}g[data-mml-node=\"mtable\"] > line[data-line], svg[data-table] > g > line[data-line] { stroke-width: 70px; fill: none;}g[data-mml-node=\"mtable\"] > rect[data-frame], svg[data-table] > g > rect[data-frame] { stroke-width: 70px; fill: none;}g[data-mml-node=\"mtable\"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed { stroke-dasharray: 140;}g[data-mml-node=\"mtable\"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted { stroke-linecap: round; stroke-dasharray: 0,140;}g[data-mml-node=\"mtable\"] > g > svg { overflow: visible;}[jax=\"SVG\"] mjx-tool { display: inline-block; position: relative; width: 0; height: 0;}[jax=\"SVG\"] mjx-tool > mjx-tip { position: absolute; top: 0; left: 0;}mjx-tool > mjx-tip { display: inline-block; padding: .2em; border: 1px solid #888; font-size: 70%; background-color: #F8F8F8; color: black; box-shadow: 2px 2px 5px #AAAAAA;}g[data-mml-node=\"maction\"][data-toggle] { cursor: pointer;}mjx-status { display: block; position: fixed; left: 1em; bottom: 1em; min-width: 25%; padding: .2em .4em; border: 1px solid #888; font-size: 90%; background-color: #F8F8F8; color: black;}foreignObject[data-mjx-xml] { font-family: initial; line-height: normal; overflow: visible;}mjx-container[jax=\"SVG\"] path[data-c], mjx-container[jax=\"SVG\"] use[data-c] { stroke-width: 3;}","url":"/blog/software/dsa/array"},{"title":"(dsa) Linked-list","content":"(dsa) Linked-listPurposeLearning linked lists is valuable because they provide a flexible and efficient data structure for dynamic memory allocation and manipulation, enabling dynamic resizing and efficient insertion, deletion, and traversal operations compared to fixed-size arrays.ConceptSingly Linked ListGraph#mark35710{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark35710 .error-icon{fill:#552222;}#mark35710 .error-text{fill:#552222;stroke:#552222;}#mark35710 .edge-thickness-normal{stroke-width:2px;}#mark35710 .edge-thickness-thick{stroke-width:3.5px;}#mark35710 .edge-pattern-solid{stroke-dasharray:0;}#mark35710 .edge-pattern-dashed{stroke-dasharray:3;}#mark35710 .edge-pattern-dotted{stroke-dasharray:2;}#mark35710 .marker{fill:#333333;stroke:#333333;}#mark35710 .marker.cross{stroke:#333333;}#mark35710 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark35710 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark35710 .cluster-label text{fill:#333;}#mark35710 .cluster-label span,#mark35710 p{color:#333;}#mark35710 .label text,#mark35710 span,#mark35710 p{fill:#333;color:#333;}#mark35710 .node rect,#mark35710 .node circle,#mark35710 .node ellipse,#mark35710 .node polygon,#mark35710 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark35710 .flowchart-label text{text-anchor:middle;}#mark35710 .node .label{text-align:center;}#mark35710 .node.clickable{cursor:pointer;}#mark35710 .arrowheadPath{fill:#333333;}#mark35710 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark35710 .flowchart-link{stroke:#333333;fill:none;}#mark35710 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark35710 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark35710 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark35710 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark35710 .cluster text{fill:#333;}#mark35710 .cluster span,#mark35710 p{color:#333;}#mark35710 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark35710 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark35710 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}ABC...Codeclass Node { constructor(value, next = null) { this.value = value; this.next = next; }}class LinkedList { constructor() { this.head = null; } // Create prepend(value) { const newNode = new Node(value); if (!this.head) { this.head = newNode; } else { newNode.next = this.head; this.head = newNode; } } append(value) { const newNode = new Node(value); if (!this.head) { this.head = newNode; } else { let tail = this.traverseTo(this.size() - 1); tail.next = newNode; } } insert(index, value) { if (index === 0) { this.prepend(value); } else if (index >= this.size()) { this.append(value); } else { const newNode = new Node(value); const leader = this.traverseTo(index - 1); const nextNode = leader.next; leader.next = newNode; newNode.next = nextNode; } } // Read traverseTo(index) { let currentNode = this.head; for (let i = 0; i < index; i++) { if (currentNode.next !== null) { currentNode = currentNode.next; } else { break; // Exit loop if end of the list is reached } } return currentNode; } size() { let count = 0; let currentNode = this.head; while (currentNode !== null) { count++; currentNode = currentNode.next; } return count; } printList() { const list = []; let currentNode = this.head; while (currentNode !== null) { list.push(currentNode.value); currentNode = currentNode.next; } return list; } // Update update(index, value) { if (index < 0 || index >= this.size()) { throw new Error('Index out of bounds'); } const target = this.traverseTo(index); target.value = value; } // Delete remove(index) { if (index < 0 || index >= this.size()) { throw new Error('Index out of bounds'); } if (index === 0) { this.head = this.head.next; } else { const leader = this.traverseTo(index - 1); const unwantedNode = leader.next; leader.next = unwantedNode.next; } }}module.exports = LinkedList;Time complexityCreate an element on head (prepend): O(1) - Creating a new node and updating the head pointer can be done in constant time without any traversal.Insert an element: O(n) - Traversing to the target position to insert the element takes time proportional to the number of nodes linked before that position.Read an element: O(n) - Traversing to the target position to read the element takes time proportional to the number of nodes linked before that position.Update an element: O(n) - Traversing to the target position to update the element takes time proportional to the number of nodes linked before that position.Delete an element: O(n) - Traversing to the target position to delete the element takes time proportional to the number of nodes linked before that position.specconst SinglyLinkedList = require('../examples/singly_linked_list.js');describe('SinglyLinkedList', () => { let testLinkedList; beforeEach(() => { testLinkedList = new SinglyLinkedList(); const values = [1, 74, 888, 62, 33]; for(let i = 0; i < values.length; i++){ testLinkedList.prepend(values[i]); } }); test('#prepend', () => { testLinkedList.prepend(0); expect(testLinkedList.printList()).toEqual([ 0, 33, 62, 888, 74, 1 ]); }); test('#append', () => { testLinkedList.append(0); expect(testLinkedList.printList()).toEqual([ 33, 62, 888, 74, 1, 0 ]); }); test('#insert', () => { testLinkedList.insert(2, 1000); expect(testLinkedList.printList()).toEqual([ 33, 62, 1000, 888, 74, 1 ]); }); test('#traverse', () => { expect(testLinkedList.traverseTo(2).value).toEqual(888); }) test('#printList', () => { expect(testLinkedList.printList()).toEqual([33, 62, 888, 74, 1]); }) test('#update', () => { testLinkedList.update(3, 4) expect(testLinkedList.printList()).toEqual([33, 62, 888, 4, 1]); }) test('#remove', () => { testLinkedList.remove(3) expect(testLinkedList.printList()).toEqual([33, 62, 888, 1]); })});Runner TechniqueConcept: two pointers iterates through a linked list at the same time.Detecting Cyclesfunction hasCycle(head) { let slow = head; let fast = head; while (fast !== null && fast.next !== null) { slow = slow.next; fast = fast.next.next; if (slow === fast) { return true; } } return false;}Finding the Middle Nodefunction findMiddle(head) { let slow = head; let fast = head; while (fast !== null && fast.next !== null) { slow = slow.next; fast = fast.next.next; } return slow;}Remove DupsProblem: Write code to remove duplicates from an unsorted linked listInformation:Example: from [1, 4, 6, 3, 2, 7, 4, 8, 3] to [1, 4, 6, 3, 2, 7, 8]You can remove any duplicate nodes you want as long as the result are all unique valuesEdge cases: Only one node in this linked listBrute force: compare each node with the rest linked nodesBest time complexity: Because we need to traverse all the nodes to read their values at least once, the time complexity will be at least O(n).Code examplefunction removeDup(linkedList) { set = new Set(); let currentNode = linkedList.head let previousNode = null while (currentNode !== null) { if (!set.has(currentNode.value)) { set.add(currentNode.value) } else { previousNode.next = currentNode.next } previousNode = currentNode currentNode = currentNode.next } return linkedList.printList()}testconst { removeDup } = require('../examples/remove_dup.js');const LinkedList = require('../examples/singly_linked_list.js');describe('RemoveDup', () => { let testLinkedList; beforeEach(() => { testLinkedList = new LinkedList(); const values = [1, 4, 6, 3, 2, 7, 4, 8, 3]; for(let i = 0; i < values.length; i++){ testLinkedList.append(values[i]); } }); test('#', () => { const result = removeDup(testLinkedList) expect(result).toEqual([1, 4, 6, 3, 2, 7, 8]); });});Return Kth to LastProblem: Implement an algorithm to find the kth to last element of a singly linked list.Information:Example: If a linked list is 1 <- 4 <- 6 <- 3 <- 2 <- 7 <- 8, then returnKthToLast(linkedList, 3) will be 6 <- 3 <- 2 <- 7 <- 8It should return a node because the node of a linked list will show all the following node values.Code example:function returnKthToLast (linkedList, k) { let counter = 1; // The first element is 1th let node = linkedList.head; while (node) { if (counter === k) { return node; } counter++; node = node.next; } return null;}module.exports = { returnKthToLast: returnKthToLast};Test:const { removeDup } = require('../examples/remove_dup.js');const LinkedList = require('../examples/singly_linked_list.js');describe('RemoveDup', () => { let testLinkedList; beforeEach(() => { testLinkedList = new LinkedList(); const values = [1, 4, 6, 3, 2, 7, 4, 8, 3]; for(let i = 0; i < values.length; i++){ testLinkedList.append(values[i]); } }); test('#', () => { const result = removeDup(testLinkedList) expect(result).toEqual([1, 4, 6, 3, 2, 7, 8]); });});Sum ListProblem: Two numbers are presented as linked list; for example, 671 as 6 -> 7 -> 1. Please write an algorithm for the sum of these two numbers; input: (6 -> 7 -> 1), (3 -> 5) and output: (7 -> 0 -> 6). p.s 671 + 35 = 706Time Complexity: I think the least time complexity is O(A + B), where A is the number of nodes of first linked list and B is the number of nodes of second linked list.Codeconst LinkedList = require('./singly_linked_list.js')function sumList(A, B) { const numberOfA = getNumber(A) const numberOfB = getNumber(B) let restNumber = numberOfA + numberOfB const result = new LinkedList() while (restNumber !== 0) { result.prepend(restNumber % 10) restNumber = Math.floor(restNumber / 10) } return result function getNumber(node) { let currentNode = node.head let number = 0 const values = [] while (currentNode != null) { values.unshift(currentNode.value) currentNode = currentNode.next } for(let i = 0; i < values.length; i++) { number += values[i] * 10 ** i } return number }}module.exports = { sumList: sumList}Test:const { sumList } = require('../examples/sum_list.js')const LinkedList = require('../examples/singly_linked_list.js')describe('sum list', () => { const linkedListA = new LinkedList() const linkedListB = new LinkedList() beforeEach(() => { const numberOfA = [6, 1, 7] // 6 is head const numberOfB = [5, 9, 2] // 2 is head for(let i = 0 ;i < numberOfA.length; i++) { linkedListA.append(numberOfA[i]) } for(let i = 0 ;i < numberOfB.length; i++) { linkedListB.append(numberOfB[i]) } }) test('return desired linked list', () => { expect(sumList(linkedListA, linkedListB).printList()).toEqual([1, 2, 0, 9]) })})Delete Middle NodeProblem: Implement an algorithm to delete a node in the middle.Example:a -> b -> c -> d -> e -> f => a -> b -> d -> e -> fa -> b -> c -> d -> e => a -> b -> d -> eEdge Case:If the linked list has only one node, then nothing will be removed from the list.Time complexity: We must need to traverse at least once to know the length, so the time complexity is at least O(n).Code example:function deleteMiddleNode(linkedList) { let fast = linkedList.head; let slow = linkedList.head; if (fast.next === null) { return } while (fast) { fast = fast.next.next preNode = slow slow = slow.next if (fast.next === null) { preNode.next = slow.next return } } return linkedList;}Test:let linkedList = new LinkedList();const values = [1, 2, 3, 5, 4, 449, 12];for(let i = 0; i < values.length; i++){ linkedList.insertAtBegin(values[i]); // return 12 <- 449 <- 4 <- 3 <- 2 <- 1}let node = deleteMiddleNode(linkedList);while (node !== null) { console.log(node.value); node = node.next;}PartitionProblem: Given a number, all nodes with value less than this number will be moved to left and all nodes with value larger than this number will be moved to right.ExampleInput: 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1Output: 3 -> 1 -> 2 -> 10 -> 5 -> 5 -> 8Edge Case:If there is only one node, then return linkedlistTime complexity: We need to traverse all nodes at least once to compare the values, so the time complexity is at least O(n).Code example:function Partition(linkedlist, value) { let node = linkedlist.head let leftPartition = new LinkedList() let rightPartition = new LinkedList() while(node) { if node.value < value { leftPartition.prepand(node) } else { rightPartition.prepand(node) } } leftPartition.printList() rightPartition.printList()}Test:const { Partition } = require('../examples/partition.js');const LinkedList = require('../examples/singly_linked_list.js');describe('Partition', () => { let testLinkedList; beforeEach(() => { testLinkedList = new LinkedList(); const values = [1, 4, 6, 3, 2, 7, 4, 8, 3]; for(let i = 0; i < values.length; i++){ testLinkedList.append(values[i]); } }); test('#', () => { const result = Partition(testLinkedList, 5) // 1, 4, 3, 2, 4, 3 // 6, 7, 8 expect(result.printList()).toEqual([1, 4, 3, 2, 4, 3, 6, 7, 8]); });});ExampleChatGPT AnswerReal-world problem that uses an linked list data structure and algorithmI want to parse the steps from a ChatGPT answer and store them as different Nodes in a linked listclass Step { constructor(data) { this.data = data; this.next = null; }}class LinkedList { constructor() { this.head = null; } addStep(data) { const newStep = new Step(data); if (!this.head) { this.head = newStep; } else { let currentStep = this.head; while (currentStep.next) { currentStep = currentStep.next; } currentStep.next = newStep; } } removeStep(data) { if (!this.head) { return; } if (this.head.data === data) { this.head = this.head.next; return; } let currentStep = this.head; while (currentStep.next) { if (currentStep.next.data === data) { currentStep.next = currentStep.next.next; return; } currentStep = currentStep.next; } }}and use this structureconst linkedList = new LinkedList();async function handleQuestion(question) { const answer = await getChatGPTResponse(question); const steps = parseSteps(answer); steps.forEach(step => linkedList.addStep(step));}function parseSteps(answer) { const steps = answer.split('\\n'); return steps.map(step => step.trim()).filter(step => step !== '');}PalindromeQuestion: Implement a function to check if a linked list is a palindrome.Example1 -> 2 -> 1 => true1 -> 2 -> 2 -> 1 => trueSeems not singly linked list? => trueTime complexityI think I still need to loop through all elements, so the it is at least O(n)Codefunction palindrome (linkedList) { let currentNode = linkedList.head let fasterNode = linkedList.head const allValues = [] const halfValues = [] while (fasterNode !== null) { halfValues.push(currentNode.value) currentNode = currentNode.next allValues.push(fasterNode.value) fasterNode = fasterNode.next if (fasterNode !== null) { allValues.push(fasterNode.value) fasterNode = fasterNode.next } } for (i = halfValues.length - 1; i >= 0; i--) { if (halfValues[i] === allValues[allValues.length - 1 - i]) { continue } else { return false } } return true}module.exports = palindromeTestconst LinkedList = require('../main.js')const palindrome = require('../examples/palindrome.js')describe('Palindrome', () => { describe('1 -> 2 -> 1', () => { const linkedList = new LinkedList beforeEach(() => { linkedList.prepend(1) linkedList.prepend(2) linkedList.prepend(1) }) test('#', () => { expect(palindrome(linkedList)).toEqual(true) }) }) describe('1 -> 2 -> 2 -> 1', () => { const linkedList = new LinkedList beforeEach(() => { linkedList.prepend(1) linkedList.prepend(2) linkedList.prepend(2) linkedList.prepend(1) }) test('#', () => { expect(palindrome(linkedList)).toEqual(true) }) }) describe('1 -> 2 -> 3 -> 1', () => { const linkedList = new LinkedList beforeEach(() => { linkedList.prepend(1) linkedList.prepend(2) linkedList.prepend(3) linkedList.prepend(1) }) test('#', () => { expect(palindrome(linkedList)).toEqual(false) }) })})IntersectionQuestion: Given two (singly) linked lists, determine if the two lists intersect. Return the intersecting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the j_th node of the second linked list, then they are intersecting.ExampleIf there is only one node in a linked list and this node is in another linked list, then they are intersected.If there are multiple shared nodes in two linked list, they are still intersected.Actually given the attribute of node, once intersected, the nodes next from the intersection are all the same.#mark58980{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark58980 .error-icon{fill:#552222;}#mark58980 .error-text{fill:#552222;stroke:#552222;}#mark58980 .edge-thickness-normal{stroke-width:2px;}#mark58980 .edge-thickness-thick{stroke-width:3.5px;}#mark58980 .edge-pattern-solid{stroke-dasharray:0;}#mark58980 .edge-pattern-dashed{stroke-dasharray:3;}#mark58980 .edge-pattern-dotted{stroke-dasharray:2;}#mark58980 .marker{fill:#333333;stroke:#333333;}#mark58980 .marker.cross{stroke:#333333;}#mark58980 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark58980 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark58980 .cluster-label text{fill:#333;}#mark58980 .cluster-label span,#mark58980 p{color:#333;}#mark58980 .label text,#mark58980 span,#mark58980 p{fill:#333;color:#333;}#mark58980 .node rect,#mark58980 .node circle,#mark58980 .node ellipse,#mark58980 .node polygon,#mark58980 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark58980 .flowchart-label text{text-anchor:middle;}#mark58980 .node .label{text-align:center;}#mark58980 .node.clickable{cursor:pointer;}#mark58980 .arrowheadPath{fill:#333333;}#mark58980 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark58980 .flowchart-link{stroke:#333333;fill:none;}#mark58980 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark58980 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark58980 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark58980 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark58980 .cluster text{fill:#333;}#mark58980 .cluster span,#mark58980 p{color:#333;}#mark58980 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark58980 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark58980 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}a1a2c1c2c3b1b2b3Codefunction findIntersection(headA, headB) { if (!headA || !headB) { return null; // One of the lists is empty, no intersection } let pointerA = headA; let pointerB = headB; while (pointerA !== pointerB) { // Move pointers to the next node, and if either reaches the end, switch to the other list pointerA = pointerA ? pointerA.next : headB; pointerB = pointerB ? pointerB.next : headA; // With switching list, we can make sure both pointer will run the same length of nodes and reach to the intersection. } return pointerA; // Return the intersection point or null if no intersection}Testconst { Node, LinkedList } = require('../main.js')const intersection = require('../examples/intersection.js')describe('intersection', () => { const nodes = ['a1', 'a2', 'c1', 'c2', 'c3', 'b1', 'b2', 'b3'].map((value) => { return new Node(value) }) describe('has intersection', () => { let linkedList1 = new LinkedList() let linkedList2 = new LinkedList() beforeEach(() => { linkedList1.prependNode(nodes[0]) linkedList1.prependNode(nodes[1]) linkedList1.prependNode(nodes[2]) linkedList1.prependNode(nodes[3]) linkedList1.prependNode(nodes[4]) linkedList2.prependNode(nodes[5]) linkedList2.prependNode(nodes[6]) linkedList2.prependNode(nodes[7]) linkedList2.prependNode(nodes[2]) linkedList2.prependNode(nodes[3]) linkedList2.prependNode(nodes[4]) }) test('#', () => { expect(intersection(linkedList1, linkedList2)).toEqual(true) }) }) describe('has no intersection', () => { let linkedList1 = new LinkedList() let linkedList2 = new LinkedList() beforeEach(() => { linkedList1.prepend(nodes[0]) linkedList1.prepend(nodes[1]) linkedList2.prepend(nodes[5]) linkedList2.prepend(nodes[6]) linkedList2.prepend(nodes[7]) }) test('#', () => { expect(intersection(linkedList1, linkedList2)).toEqual(false) }) })})Loop DetectionQuestion: Given a circular linked list, implement an algorithm that returns the node at the beginning of the loop.Example:Input: A -> B -> C -> D -> E -> COutput: CTime complexity: I think the least complexity will be O(n) because I at least need to traverse all the nodesCodefunction loopDetection(linkedList) { hash = {} currentNode = linkedList.head while(currentNode) { if(!hash[currentNode.value]) { hash[currentNode.value] = [currentNode] } else if(hash[currentNode.value]) { if(hash[currentNode.value].include(currentNode)) { return currentNode.value } } else { currentNode = currentNode.next } } return false}Testdescribe('loop detection', () => { let values = ['A', 'B', 'C', 'D', 'E'] let nodes = values.map((value) => {new Node(value)}) let linkedList = new LinkedList() linkedList.prependNode(nodes[2]) linkedList.prependNode(nodes[4]) linkedList.prependNode(nodes[3]) linkedList.prependNode(nodes[2]) linkedList.prependNode(nodes[1]) test('#', () => { expect(loopDetection(linkedList)).toEqual('C') })})GPT tells me to use Floyd's Tortoise and Hare algorithmFloyd Tortoise and HareFloyd's Tortoise and Hare algorithm is a cycle detection technique used to find a cycle in a linked list by moving two pointers at different speeds; it's efficient and helps detect cycles in constant space.function floydTortoiseHare(linkedList) { let fast = linkedList.head let slow = fast.next while(slow) { if(fast !== slow) { fast = fast.next slow = slow.next.next } else { return true } } return false}With this algorithm, the space complexity is O(1) because we only need two slot for storing values of fast and slow nodes.AppendixDoubly Linked ListGraph<div class=\"mermaid\"> graph LR id1((A)) --> id2((B)) id2((B)) --> id1((A)) id2((B)) --> id3((C)) id3((C)) --> id2((B)) id3((C)) --> id4((...)) id4((...)) --> id3((C))</div>coding example:class Node { constructor(data) { this.data = data; this.prev = null; this.next = null; }} class DoublyLinkedList { constructor() { this.head = null; this.tail = null; } // create append(data) { // create a node on the tail const newNode = new Node(data); if (this.head === null) { this.head = newNode; this.tail = newNode; } else { this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; } } prepend(data) { // create a node on the head const newNode = new Node(data); if (this.head === null) { this.head = newNode; this.tail = newNode; } else { this.head.prev = newNode; newNode.next = this.head; this.head = newNode; } } insert(position, data) { // create a node on particular position const newNode = new Node(data); if (this.head === null) { this.head = newNode; this.tail = newNode; } else if (position > this.length) { this.append(data) } else { const nodeOnPosition = this.traverseToIndex(position - 1); newNode.next = nodeOnPosition; newNode.prev = nodeOnPosition.prev; newNode.prev.next = newNode; } } // read value() { // return the value of node in particular position } values() { // return values from head let current_node = this.head; const result = []; while (current_node !== null) { result.push(current_node.data); current_node = current_node.next; } return result } reverseValues() { // return values from tail let current_node = this.tail; const result = []; while (current_node !== null) { result.push(current_node.data); current_node = current_node.prev; } return result } // traverse traverseToIndex(index) { let currentNode = this.head; for (let i = 0; i < index; i++) { currentNode = currentNode.next; } return currentNode; } // update update(position, value) { // update the value on particular position } // delete remove(position) { // remove the node on particular position if (this.head === null) { return; } if (this.head === this.tail && this.head.data === data) { this.head = null; this.tail = null; return; } if (this.head.data === data) { this.head = this.head.next; this.head.prev = null; return; } let current_node = this.head.next; while (current_node !== null && current_node.data !== data) { current_node = current_node.next; } if (current_node === null) { return; } if (current_node === this.tail) { this.tail = this.tail.prev; this.tail.next = null; return; } current_node.prev.next = current_node.next; current_node.next.prev = current_node.prev; }}module.exports = DoublyLinkedListwhy we need doubly?Traversal in both directions(?) Insertion and deletion at any position: In a singly linked list, if you want to insert a node between two nodes, you need to modify the pointers of the previous node to point to the new node, and the new node to point to the next node. With a doubly linked list, you can simply update the pointers of the neighboring nodes to insert a node in between them. Similarly, when deleting a node from a doubly linked list, you can easily update the pointers of the neighboring nodes to remove the node.Specconst DoublyLinkedList = require('../examples/doubly_linked_list.js');describe('DoublyLinkedList', () => { let testLinkedList; beforeEach(() => { testLinkedList = new DoublyLinkedList(); const values = [1, 74, 888, 62, 33]; for(let i = 0; i < values.length; i++){ // 33 <- 62 <- 888 <- 74 <- 1 testLinkedList.prepend(values[i]); } }); test('#prepend', () => { // 0 <- 33 <- 62 <- 888 <- 74 <- 1 testLinkedList.prepend(0); expect(testLinkedList.values()).toEqual([ 0, 33, 62, 888, 74, 1 ]); expect(testLinkedList.reverseValues()).toEqual([ 1, 74, 888, 62, 33, 0 ]); }); test('#append', () => { // 33 <- 62 <- 888 <- 74 <- 1 <- 0 testLinkedList.append(0); expect(testLinkedList.values()).toEqual([ 33, 62, 888, 74, 1, 0 ]); expect(testLinkedList.reverseValues()).toEqual([ 0, 1, 74, 888, 62, 33 ]); }); test('#insert', () => { // 33 <- 1000 <- 62 <- 888 <- 74 <- 1 testLinkedList.insert(2, 1000); expect(testLinkedList.values()).toEqual([ 33, 1000, 62, 888, 74, 1 ]); }); test('#update', () => { testLinkedList.update(2, 1000); expect(testLinkedList.printList()).toEqual([ 33, 1000, 888, 74, 1 ]); }) test('#delete', () => { testLinkedList.update(2, 1000); expect(testLinkedList.printList()).toEqual([ 33, 1000, 888, 74, 1 ]); })});referencecracking the coding interviewPractical Linked List in RubyLinked Lists in JavaScript (ES6 code)The Jest Object","url":"/blog/software/dsa/linked-list"},{"title":"(dsa) Hash-table","content":"(dsa) Hash-tablePurposeHash tables provide fast and efficient storage and retrieval of key-value pairs.ConceptFor example, we create a hash table where items are linked list.#mark40437{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark40437 .error-icon{fill:#552222;}#mark40437 .error-text{fill:#552222;stroke:#552222;}#mark40437 .edge-thickness-normal{stroke-width:2px;}#mark40437 .edge-thickness-thick{stroke-width:3.5px;}#mark40437 .edge-pattern-solid{stroke-dasharray:0;}#mark40437 .edge-pattern-dashed{stroke-dasharray:3;}#mark40437 .edge-pattern-dotted{stroke-dasharray:2;}#mark40437 .marker{fill:#333333;stroke:#333333;}#mark40437 .marker.cross{stroke:#333333;}#mark40437 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark40437 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark40437 .cluster-label text{fill:#333;}#mark40437 .cluster-label span,#mark40437 p{color:#333;}#mark40437 .label text,#mark40437 span,#mark40437 p{fill:#333;color:#333;}#mark40437 .node rect,#mark40437 .node circle,#mark40437 .node ellipse,#mark40437 .node polygon,#mark40437 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark40437 .flowchart-label text{text-anchor:middle;}#mark40437 .node .label{text-align:center;}#mark40437 .node.clickable{cursor:pointer;}#mark40437 .arrowheadPath{fill:#333333;}#mark40437 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark40437 .flowchart-link{stroke:#333333;fill:none;}#mark40437 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark40437 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark40437 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark40437 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark40437 .cluster text{fill:#333;}#mark40437 .cluster span,#mark40437 p{color:#333;}#mark40437 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark40437 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark40437 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}Bucketsinsert value 1insert value 2insert value 3key 0key 1key 2key 3...value 1hash functionvalue 2value 3value 1value 2value 3The value will be calculated by self-defined method in hash function to get the key of buckets and then connects the value with linked list if the mapping key is the same.Given the length of buckets is N, meaning there are N keys, if we want to search an element, it will first pass the element into hash function to get the key for certain linked list and then search through the linked list.The time complexity = , where A is the length of bucket and B is the length of linked list.A is actually 1 because the keys are stored in array, so we can access the item in O(1). Please refer to array to see why read an element with given index is O(1).B is usually close to 1 if we making the collisions, meaning values map to same key, as low as possible. As a result, the time complexity is actually O(1).two sumQuestionInput: nums = [2, 7, 11, 15], target = 9Output: [0, 1]Explanation: nums[0] + nums[1] equals 9, so the indices are 0 and 1.Input: nums = [3, 2, 4], target = 6Output: [1, 2]Input: nums = [3, 3], target = 6Output: [0, 1]Codefunction twoSum (array, target) { const hash = {} for (i = 0; i < array.length; i++) { if (hash[array[i]] !== undefined) { return [hash[array[i]], i] } else { hash[target - array[i]] = i } } return 'no'}module.exports = twoSumTesttwoSum = require('../examples/two_sum.js')describe('Tow Sum', () => { test('[2, 7, 11, 15], target = 9', () => { expect(twoSum([2, 7, 11, 15], 9)).toEqual([0, 1]) }) test('[3, 2, 4], target = 6', () => { expect(twoSum([3, 2, 4], 6)).toEqual([1, 2]) }) test('[3, 3], target = 6', () => { expect(twoSum([3, 3], 6)).toEqual([0, 1]) })})ExampleReal world example: counting the words of an articleclass WordCounter { constructor() { this.wordCountMap = new Map(); } countWords(article) { const words = article.trim().split(/\\s+/); for (const word of words) { const normalizedWord = word.toLowerCase(); const count = this.wordCountMap.get(normalizedWord) || 0; this.wordCountMap.set(normalizedWord, count + 1); } } getWordCount(word) { const normalizedWord = word.toLowerCase(); return this.wordCountMap.get(normalizedWord) || 0; } getTopWords(limit) { const sortedEntries = Array.from(this.wordCountMap.entries()).sort((a, b) => b[1] - a[1]); return sortedEntries.slice(0, limit).map(([word, count]) => ({ word, count })); }}ReferenceGPTmjx-container[jax=\"SVG\"] { direction: ltr;}mjx-container[jax=\"SVG\"] > svg { overflow: visible; min-height: 1px; min-width: 1px;}mjx-container[jax=\"SVG\"] > svg a { fill: blue; stroke: blue;}mjx-container[jax=\"SVG\"][display=\"true\"] { display: block; text-align: center; margin: 1em 0;}mjx-container[jax=\"SVG\"][display=\"true\"][width=\"full\"] { display: flex;}mjx-container[jax=\"SVG\"][justify=\"left\"] { text-align: left;}mjx-container[jax=\"SVG\"][justify=\"right\"] { text-align: right;}g[data-mml-node=\"merror\"] > g { fill: red; stroke: red;}g[data-mml-node=\"merror\"] > rect[data-background] { fill: yellow; stroke: none;}g[data-mml-node=\"mtable\"] > line[data-line], svg[data-table] > g > line[data-line] { stroke-width: 70px; fill: none;}g[data-mml-node=\"mtable\"] > rect[data-frame], svg[data-table] > g > rect[data-frame] { stroke-width: 70px; fill: none;}g[data-mml-node=\"mtable\"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed { stroke-dasharray: 140;}g[data-mml-node=\"mtable\"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted { stroke-linecap: round; stroke-dasharray: 0,140;}g[data-mml-node=\"mtable\"] > g > svg { overflow: visible;}[jax=\"SVG\"] mjx-tool { display: inline-block; position: relative; width: 0; height: 0;}[jax=\"SVG\"] mjx-tool > mjx-tip { position: absolute; top: 0; left: 0;}mjx-tool > mjx-tip { display: inline-block; padding: .2em; border: 1px solid #888; font-size: 70%; background-color: #F8F8F8; color: black; box-shadow: 2px 2px 5px #AAAAAA;}g[data-mml-node=\"maction\"][data-toggle] { cursor: pointer;}mjx-status { display: block; position: fixed; left: 1em; bottom: 1em; min-width: 25%; padding: .2em .4em; border: 1px solid #888; font-size: 90%; background-color: #F8F8F8; color: black;}foreignObject[data-mjx-xml] { font-family: initial; line-height: normal; overflow: visible;}mjx-container[jax=\"SVG\"] path[data-c], mjx-container[jax=\"SVG\"] use[data-c] { stroke-width: 3;}","url":"/blog/software/dsa/hash-table"},{"title":"(dsa) Tree","content":"(dsa) TreePurposeLearning tree data structures is essential for organizing and efficiently accessing hierarchical data, such as file systems, organizational structures, and decision-making processes.Concepttypes of treeGeneral tree: each node has 0 to many child node#mark87463{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark87463 .error-icon{fill:#552222;}#mark87463 .error-text{fill:#552222;stroke:#552222;}#mark87463 .edge-thickness-normal{stroke-width:2px;}#mark87463 .edge-thickness-thick{stroke-width:3.5px;}#mark87463 .edge-pattern-solid{stroke-dasharray:0;}#mark87463 .edge-pattern-dashed{stroke-dasharray:3;}#mark87463 .edge-pattern-dotted{stroke-dasharray:2;}#mark87463 .marker{fill:#333333;stroke:#333333;}#mark87463 .marker.cross{stroke:#333333;}#mark87463 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark87463 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark87463 .cluster-label text{fill:#333;}#mark87463 .cluster-label span,#mark87463 p{color:#333;}#mark87463 .label text,#mark87463 span,#mark87463 p{fill:#333;color:#333;}#mark87463 .node rect,#mark87463 .node circle,#mark87463 .node ellipse,#mark87463 .node polygon,#mark87463 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark87463 .flowchart-label text{text-anchor:middle;}#mark87463 .node .label{text-align:center;}#mark87463 .node.clickable{cursor:pointer;}#mark87463 .arrowheadPath{fill:#333333;}#mark87463 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark87463 .flowchart-link{stroke:#333333;fill:none;}#mark87463 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark87463 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark87463 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark87463 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark87463 .cluster text{fill:#333;}#mark87463 .cluster span,#mark87463 p{color:#333;}#mark87463 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark87463 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark87463 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}ABCDEFGHIJBinary tree: each node has at most 2 child modes#mark45888{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark45888 .error-icon{fill:#552222;}#mark45888 .error-text{fill:#552222;stroke:#552222;}#mark45888 .edge-thickness-normal{stroke-width:2px;}#mark45888 .edge-thickness-thick{stroke-width:3.5px;}#mark45888 .edge-pattern-solid{stroke-dasharray:0;}#mark45888 .edge-pattern-dashed{stroke-dasharray:3;}#mark45888 .edge-pattern-dotted{stroke-dasharray:2;}#mark45888 .marker{fill:#333333;stroke:#333333;}#mark45888 .marker.cross{stroke:#333333;}#mark45888 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark45888 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark45888 .cluster-label text{fill:#333;}#mark45888 .cluster-label span,#mark45888 p{color:#333;}#mark45888 .label text,#mark45888 span,#mark45888 p{fill:#333;color:#333;}#mark45888 .node rect,#mark45888 .node circle,#mark45888 .node ellipse,#mark45888 .node polygon,#mark45888 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark45888 .flowchart-label text{text-anchor:middle;}#mark45888 .node .label{text-align:center;}#mark45888 .node.clickable{cursor:pointer;}#mark45888 .arrowheadPath{fill:#333333;}#mark45888 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark45888 .flowchart-link{stroke:#333333;fill:none;}#mark45888 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark45888 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark45888 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark45888 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark45888 .cluster text{fill:#333;}#mark45888 .cluster span,#mark45888 p{color:#333;}#mark45888 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark45888 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark45888 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}1792695115The rectangle means no dataTypeSelf-balancing: Balance means that the tree remains relatively symmetric and prevents it from becoming skewed or heavily imbalanced.Complete: Complete means that except last level, all levels' node has 0 or 2 children.Full: Full means every node has 0 or 2 children.Perfect: Perfect means all nodes have two children and all leaves are at the same leveltypes of traversalGiven a tree as follow: (The rectangle means no data)#mark65758{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark65758 .error-icon{fill:#552222;}#mark65758 .error-text{fill:#552222;stroke:#552222;}#mark65758 .edge-thickness-normal{stroke-width:2px;}#mark65758 .edge-thickness-thick{stroke-width:3.5px;}#mark65758 .edge-pattern-solid{stroke-dasharray:0;}#mark65758 .edge-pattern-dashed{stroke-dasharray:3;}#mark65758 .edge-pattern-dotted{stroke-dasharray:2;}#mark65758 .marker{fill:#333333;stroke:#333333;}#mark65758 .marker.cross{stroke:#333333;}#mark65758 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark65758 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark65758 .cluster-label text{fill:#333;}#mark65758 .cluster-label span,#mark65758 p{color:#333;}#mark65758 .label text,#mark65758 span,#mark65758 p{fill:#333;color:#333;}#mark65758 .node rect,#mark65758 .node circle,#mark65758 .node ellipse,#mark65758 .node polygon,#mark65758 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark65758 .flowchart-label text{text-anchor:middle;}#mark65758 .node .label{text-align:center;}#mark65758 .node.clickable{cursor:pointer;}#mark65758 .arrowheadPath{fill:#333333;}#mark65758 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark65758 .flowchart-link{stroke:#333333;fill:none;}#mark65758 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark65758 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark65758 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark65758 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark65758 .cluster text{fill:#333;}#mark65758 .cluster span,#mark65758 p{color:#333;}#mark65758 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark65758 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark65758 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}1792695115There are three actions we can do in current nodeVisit (return the value of current node)Left (traverse to the left node)Right (traverse to the right node)After each traverse, redo it from beginInorder traversals (L > V > R): traverse(1) -> [traverse(7), push(1), traverse(9)] -> [traverse(2), push(7), traverse(6)], push(1), [null, push(9), traverse(9)] -> ... -> 2 -> 7 -> 5 -> 6 -> 11 -> 1 -> 9 -> 5 -> 9Preorder traversals (V > L > R): traverse(1) -> [push(1), traverse(7), traverse(9)] -> [push(1), push(7), traverse(2), traverse(6), push(9), traverse(null), traverse(9)] -> ... -> 1 -> 7 -> 2 -> 6 -> 5 -> 11 -> 9 -> 9 -> 5Postorder traversals (L > R > V): traverse(1) -> [traverse(7), traverse(9), push(1)] -> [traverse(2), traverse(6), push(7), traverse(null), traverse(9), push(9), push(1)] -> ... -> 2 -> 5 -> 11 -> 6 -> 7 -> 5 -> 9 -> 9 -> 1Essential StructureTree:class Tree { constructor(key, value) { this.root = null; // will use insert to create this root } traversal(node = this.root) { } insert() { // we can only insert node as leaf } remove() { } find() { }}class TreeNode { constructor(key, value = key, parent = null) { this.key = key; this.value = value; this.parent = parent; this.children = []; } get isLeaf() { } get hasChildren() { }}Binary TreeDiagram (the number of left node is not necessary smaller than the right node) a / \\ b c / \\ / \\ d e f gcode exampleclass BinaryTreeNode { constructor(key, value = key, parent = null) { this.key = key; this.value = value; this.parent = parent; this.left = null; this.right = null; }}class BinaryTree { constructor() { this.root = null; } addNode(value) { // will use recursive if (this.root === null) { this.root = new BinaryTreeNode(value) } else { this.insertNode(this.root, new BinaryTreeNode(value)) } } inorderTraversal() { // L > V > R const result = []; function traverse(node) { if (node) { traverse(node.left); result.push(node.value); traverse(node.right); } } traverse(this.root); return result; } preorderTraversal() { // V > L > R const result = []; function traverse(node) { if (node) { result.push(node.value) traverse(node.left); traverse(node.right); } } traverse(this.root); return result } postorderTraversal() { // L > R > V const result = []; function traverse(node) { if (node) { traverse(node.left); traverse(node.right); result.push(node.value) } } traverse(this.root); return result } levelorderTraversal() { // [5, 3, 8, 2, 4, 7, 9] const queue = [this.root] const result = [] if (!this.root) { return } while (queue.length > 0) { const node = queue.shift() result.push(node.value) if (node.left !== null) { queue.push(node.left) } if (node.right !== null) { queue.push(node.right) } } return result } insertNode(parentNode, newNode) { // there is no specific insertion method for binary tree }}module.exports = BinaryTreeBinary Search TreeA Binary Search Tree (BST) is a data structure with nodes containing a value and two pointers to left and right child nodes, facilitating efficient search and insertion by moving left or right based on the comparison of values, with the efficiency depending on the balance of the tree.Diagram 5 / \\ 3 8 / \\ / \\ 2 4 7 9The value of left node is alway smaller than the value of right node.Code exampleBinaryTree = require('./binary_tree.js')Node = require('./binary_tree_node.js')class BinarySearchTree extends BinaryTree { constructor(root) { super(root); } // Create addNode(value) { // will use recursive if (this.root === null) { this.root = new Node(value) } else { this._insertNode(this.root, new Node(value)) } } // Read search(value) { result = this._searchNode(value, this.root) if (result !== null) { return true } else { return false } } // Update updateValue(node, newValue) { target = this._searchNode(value, this.root) target.value = newValue } _insertNode(parentNode, newNode) { if(newNode.value < parentNode.value){ if(parentNode.left === null) { parentNode.left = newNode; } else { this.insertNode(parentNode.left, newNode); } } else { if(parentNode.right === null) { parentNode.right = newNode; } else { this.insertNode(parentNode.right, newNode); }; }; } _searchNode(value, node) { if (node === null) { return null; } else if (value < node.value) { return this.search(value, node.left); } else if (value > node.value) { return this.search(value, node.right); } else { return node; } }}module.exports = BinarySearchTreeTime complexity of CRUDCreate a node: O(log n) - O(n)Inserting a new node into a binary tree requires finding the correct position for the new node in the tree. In the worst case, this involves traversing the height of the tree, which has a time complexity of O(log n) for a balanced binary tree and O(n) for an unbalanced binary tree.read: O(log n) - O(n)The number of operation is proportionate to the layer of nodes, so the time complexity is O(log n) in balanced tree and O(n) in unbalanced tree; no matter what the traversal method is.update: O(log n) - O(n)Before updating the value of a node, we need to traverse to the target node, which is proportionate to the layers of tree, so it is O(log n) for balanced tree and O(n) for unbalanced tree.delete: O(log n) to O(n)Deleting a node from a binary tree requires finding the node to be deleted and then rearranging the tree to maintain its properties. In the worst case, this also involves traversing the height of the tree, which has a time complexity of O(log n) for a balanced binary tree and O(n) for an unbalanced binary tree.specconst BinaryTree = require('../examples/binary_tree.js');describe('BinaryTree', () => {// 10// / \\// 5 15// / \\ / \\// 3 7 12 17 let testTree; beforeEach(() => { testTree = new BinaryTree(); testTree.addNode(10); testTree.addNode(5); testTree.addNode(15); testTree.addNode(3); testTree.addNode(7); testTree.addNode(12); testTree.addNode(17); }); test('#init', () => { expect(testTree.root.value).toBe(10) expect(testTree.root.left.value).toBe(5) expect(testTree.root.left.left.value).toBe(3) expect(testTree.root.left.right.value).toBe(7) expect(testTree.root.right.value).toBe(15) expect(testTree.root.right.left.value).toBe(12) expect(testTree.root.right.right.value).toBe(17) }) test('#search', () => { expect(testTree.search(10)).toEqual({ value: 10, left: { value: 5, left: { value: 3, left: null, right: null }, right: { value: 7, left: null, right: null } }, right: { value: 15, left: { value: 12, left: null, right: null }, right: { value: 17, left: null, right: null } } }) }) test('#inorderTraversal', () => { // L > V > R expect(testTree.inorderTraversal()).toEqual([3, 5, 7, 10, 12, 15, 17]) }) test('#preorderTraversal', () => { // V > L > R expect(testTree.preorderTraversal()).toEqual([10, 5, 3, 7, 15, 12, 17]) }) test('#postorderTraversal', () => { // L > R > V expect(testTree.postorderTraversal()).toEqual([3, 7, 5, 12, 17, 15, 10]) }) test('#levelorderTraversal', () => { expect(testTree.levelorderTraversal()).toEqual([10, 5, 15, 3, 7, 12, 17]) })});Height of Binary TreeGiven a binary tree, return the height; for exampleQAexample 1Input: 1 / \\ 2 3Output: 2example 2Input: 2 \\ 1 / 3Output: 3code examplefunction maxDepth(node) { if(node == null) { return 0 } lDepth = maxDepth(node.left) rDepth = maxDepth(node.right) if(lDepth > rDepth) { return lDepth + 1 } else { return rDepth + 1 }}module.exports = maxDepthspecconst Node = require('../examples/binary_tree_node.js')const maxDepth = require('../examples/max_depth.js')describe('MaxDepth', () => { let tree describe('example 1', () => { // Input: // 1 // / \\ // 2 3 // Output: 2 beforeEach(async () => { tree = new Node(1) tree.left = new Node(2) tree.right = new Node(3) }) test('#', () => { expect(maxDepth(tree)).toEqual(2) }) }) describe('example 2', () => { // Input: // 2 // \\ // 1 // / // 3 // Output: 3 beforeEach(async () => { tree = new Node(2) tree.right = new Node(1) tree.right.left = new Node(3) }) test('#', () => { expect(maxDepth(tree)).toEqual(3) }) })})Minimal TreeProblem: Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.InformationExample: [1, 2, 3, 4, 5, 6] 1 / \\ 2 3 / \\ / \\ 4 5 6 Time complexity: O(n) since we must need to traverse the nodes onceCode example:class MinimalTree { constructor() { this.root = null; } addNode(value, currentNode = this.root) { // will use recursive if (this.root === null) { this.root = new Node(value) } else if (currentNode.left === null) { currentNode.left = addNode(value) } else { currentNode.right = addNode(value) } } height() { let result = 0 currentNode = this.root while(currentNode) { result += 1 currentNode = currentNode.left } return result }}module.exports = MinimalTreeSpec:describe('minimal tree', () => { test('6 elements', () => { let testTree = new MinimalTree() let currentNode = null values = [1, 2, 3, 4, 5, 6] values.forEach((value) => { testTree.addNode(value); }) expect(testTree.height()).toEqual(3) })})List of DepthsQuestion: Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth.Example: (e.g., if you have a tree with depth D, you'll have D linked lists).Normal 1 / \\2 3// result: 1 -> 2 -> 3Edge 1 / \\ 2 \\ 3I can either create new nodes or use the same nodes to construct the linked list.Codefunction listOfDepths (binaryTree) { const root = binaryTree.root const nodes = [] const queue = [] queue.push(root) while (queue.length !== 0) { const insertNode = queue.pop() nodes.push(insertNode) if (insertNode.left !== null) queue.push(insertNode.left) if (insertNode.right !== null) queue.push(insertNode.right) } linkedList = new LinkedList() let previousNode for (let i = 0; i < nodes.length; i ++) { if (linkedList.head === null) { linkedList.head = nodes[i] previousNode = nodes[i] } else { previousNode.next = nodes[i] } } return linkedList}Testdescribe('List Of Depths', () => { describe('', () => { let binaryTree beforeEach('', () => { const values = [1, 2, 3] for (i = 0; i < values.length; i++) { binaryTree.addNode(values[i]) } }) // 1 // / \\ // 2 3 test('#', () => { expect(listOfDepths(binaryTree).printList()).toEqual([1, 2, 3]) }) })})Check BalancedQuestion: Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.ExampleThe tree is binary treeIt is impossible that the nodes are singly connectedCodefunction checkBalanced(tree) { if(tree === null) { // null tree is balanced return true } else if(Math.abs(height(tree.left) - height(tree.right)) <= 1) { return true } else if(!checkBalanced(tree.left)) { return false } else if(!checkBalanced(tree.right)) { return false } else { return true } const height = (tree) => { if(tree === null) { return 0 } else { return 1 + Math.max(height(tree.left), height(tree.right)) } }}Test// Skip, I found it takes too much time on creating the right dataValidate BSTQuestion: Implement a function to check if a binary tree is a binary search tree.ExampleThe left node must smaller or equal to the right nodeCheck it recursivelyCodefunction validateBST(tree) { if (node === null) { return true; // An empty tree is a valid BST. } if (node.value <= min || node.value >= max) { // It is a better idea to use node value to check whether it is truly smaller than the righter node and larger to the lefter node. return false; // Node value violates BST property. } // Check left subtree with updated max value, and right subtree with updated min value. return ( validateBST(node.left, min, node.value) && validateBST(node.right, node.value, max) );}You may think that if node === null return true is wrong. But if the code can run to here, it means all the nodes with children pass validateBST which means this tree is BST.Testdescribe('validate BST', () => { let tree = new BinaryTree() describe('BST', () => { // 10 // / \\ // 5 15 // / \\ / \\ // 3 7 12 17 test.addNode(10); test.addNode(5); test.addNode(15); test.addNode(3); test.addNode(7); test.addNode(12); test.addNode(17); test(validateBST(tree)).toEqual(true) })})SuccessorQuestion: Write an algorithm to find the \"next\" node (i.e., in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent.ExampleInput: a node but not a value because there may be two different node with same valueOutput: the in-order successor's valueBecause each node is a tree, so I can keep doing in-order traversal on that node.In-order means LVR// Input 20 / \\ 8 22 / \\4 12 / \\ 10 14// Output22// And input, 8 -> Output: 10// And input, 4 -> Output: nullTime complexity: The time complexity seems O(h), where h is the height of the right sub tree (log(n)).Codefunction successor(node) { if(node === null) { return null } let rightSubTree = node.right while(rightSubTree.left) { rightSubTree = rightSubTree.left } return rightSubTree}First Common AncestorQuestion: Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a binary search tree.ExampleEdge one: The tree is nullEdge two: A node is ancestor of the otherTime complexity: It at least need to traverse all nodes, so O(n)Codefunction firstCommonAncestor(tree, node1, node2) { if(!tree) { return null // edge 1 } if(tree === node1 || tree === node2) { return tree // edge 2 } leftResult = firstCommonAncestor(tree.left, node1, node2) rightResult = firstCommonAncestor(tree.right, node1, node2) if(leftResult && rightResult) { return tree // if both leftResult and rightResult find node, return the current tree } return null}TODOBST SequencesCheck SubtreeRandom NodePaths with SumReal world exampleA real world example of implementing a decision treeclass DecisionTreeNode { constructor(question, yesNode, noNode) { this.question = question; this.yesNode = yesNode; this.noNode = noNode; } ask() { console.log(this.question); let answer = prompt(\"Enter yes or no:\"); if (answer === \"yes\") { if (this.yesNode instanceof DecisionTreeNode) { return this.yesNode.ask(); } else { console.log(this.yesNode); } } else if (answer === \"no\") { if (this.noNode instanceof DecisionTreeNode) { return this.noNode.ask(); } else { console.log(this.noNode); } } else { console.log(\"Invalid input. Please enter yes or no.\"); return this.ask(); } }}let root = new DecisionTreeNode( \"Is it a mammal?\", new DecisionTreeNode( \"Does it have fur?\", new DecisionTreeNode(\"Is it a cat?\", \"It's a cat!\"), new DecisionTreeNode(\"Is it a whale?\", \"It's a whale!\") ), new DecisionTreeNode( \"Does it have feathers?\", new DecisionTreeNode(\"Is it a bird?\", \"It's a bird!\"), new DecisionTreeNode(\"Is it a snake?\", \"It's a snake!\") ));root.ask();Each node has a question, a yesNode branch and a noNode branch. The ask() method of the node prompts the user to answer the question and then follows the appropriate branch based on the answer. If the branch is another DecisionTreeNode, it recursively calls the ask() method on that node. If the branch is a leaf node, it simply returns the corresponding result.Referencecracking the coding interviewJavaScript Data Structures - TreeWhat's the purpose of an asterisk (*) in ES6 generator functionsTree Traversals (Inorder, Preorder and Postorder)Binary Tree: Traversal(尋訪)Global and instance modeDifference between Binary Tree and Binary Search TreeTop 50 Tree Coding Problems for InterviewsIs there a difference between perfect, full and complete tree?","url":"/blog/software/dsa/tree"},{"title":"(dsa) Graph","content":"(dsa) GraphPurposeGraphs are valuable tools for visually representing the relationships and connections among data points, enabling us to easily discern patterns and gain insightful observations.ConceptBasic ConceptLet's look at following undirected graph. There are vertices and edges and we are going to research how to use data structure to represent it.#mark74221{font-family:monospace;font-size:16px;fill:#333;}#mark74221 .error-icon{fill:#552222;}#mark74221 .error-text{fill:#552222;stroke:#552222;}#mark74221 .edge-thickness-normal{stroke-width:2px;}#mark74221 .edge-thickness-thick{stroke-width:3.5px;}#mark74221 .edge-pattern-solid{stroke-dasharray:0;}#mark74221 .edge-pattern-dashed{stroke-dasharray:3;}#mark74221 .edge-pattern-dotted{stroke-dasharray:2;}#mark74221 .marker{fill:#333333;stroke:#333333;}#mark74221 .marker.cross{stroke:#333333;}#mark74221 svg{font-family:monospace;font-size:16px;}#mark74221 .label{font-family:monospace;color:#333;}#mark74221 .cluster-label text{fill:#333;}#mark74221 .cluster-label span,#mark74221 p{color:#333;}#mark74221 .label text,#mark74221 span,#mark74221 p{fill:#333;color:#333;}#mark74221 .node rect,#mark74221 .node circle,#mark74221 .node ellipse,#mark74221 .node polygon,#mark74221 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark74221 .flowchart-label text{text-anchor:middle;}#mark74221 .node .label{text-align:center;}#mark74221 .node.clickable{cursor:pointer;}#mark74221 .arrowheadPath{fill:#333333;}#mark74221 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark74221 .flowchart-link{stroke:#333333;fill:none;}#mark74221 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark74221 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark74221 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark74221 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark74221 .cluster text{fill:#333;}#mark74221 .cluster span,#mark74221 p{color:#333;}#mark74221 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:monospace;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark74221 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark74221 :root{--mermaid-font-family:monospace;}0132Vertices: Based on the nodes in the flowchart, the vertices can be represented by the numbers 0, 1, 2, and 3.Edges: Based on the connections between the nodes in the flowchart, the edges can be considered as undirected edges connecting the vertices.RepresentationThere are three ways: adjacency matrices, adjacency lists, edge lists.Adjacency matrices of undirected edges | 0 | 1 | 2 | 3 |---------------------0 | 0 | 1 | 1 | 1 |1 | 1 | 1 | 0 | 1 |2 | 1 | 0 | 0 | 1 |3 | 1 | 1 | 1 | 0 |The value 1 represents the presence of an edge between two vertices. If the edge is undirected, there will be 1 in both intersected cells.Adjacency lists (what I prefer, please refer to here)0: [1, 3]1: [1]2: [0]3: [1, 2]Each vertex is associated with a list of vertices it is connected to.For example, vertex 0 is connected to vertices 1 and 3.Edge lists[(0, 1), (0, 3), (1, 1), (2, 0), (3, 1), (3, 2)]Each tuple represents an edge between two vertices.For example, there is an edge from vertex 0 to vertex 1, from vertex 0 to vertex 3, and so on.Basic FormHere we are going to use adjacency list to build the class of undirected graph.Basic data structure of the graph aboveconst graph = { // adjacency lists 0: [1, 2], 1: [0, 1, 3], 2: [0, 3], 3: [0, 1, 2]};Code exampleclass Graph { // Adjacency list form // Undirected edges // No attributes on edges and nodes constructor() { this.adjacencyList = {}; } // Create addVertex(vertex) { this.adjacencyList[vertex] = []; } addEdge(vertex1, vertex2) { // push both side because it is undirected this.adjacencyList[vertex1].push(vertex2); this.adjacencyList[vertex2].push(vertex1); } // Read getNeighbors(vertex) { return this.adjacencyList[vertex]; } getVertices() { return Object.keys(this.adjacencyList); } getEdges() { // It will return Set of arrays const edges = new Set() for (let [vertexOne, vertexTwos] of Object.entries(this.adjacencyList)) { vertexTwos.forEach((vertexTwo) => {edges.add([parseInt(vertexOne), vertexTwo])}) } return edges } findVertex(vertex) { return this.vertices.has(vertex) } findEdge(vertex1, vertex2) { return this.vertices.get(vertex1).has(vertex2) && this.vertices.get(vertex2).has(vertex1) } // Update // There will be no update methods for vertex and edge because in this class there is no attributes for both of them. // Destroy removeEdge(vertex1, vertex2) { let index2 = this.adjacencyList[vertex1].indexOf(vertex2) let index1 = this.adjacencyList[vertex2].indexOf(vertex1) if (index2 > -1) { this.adjacencyList[vertex1].splice(index2, 1) } if (index1 > -1) { this.adjacencyList[vertex2].splice(index1, 1) } } removeVertex(vertex) { while (this.adjacencyList[vertex].length) { neighborVertex = this.adjacencyList[vertex].pop(); this.removeEdge(vertex, neighborVertex) } }}module.exports = Graph;specconst Graph = require('../examples/graph.js');describe('Graph', () => { let testGraph beforeEach(() => { testGraph = new Graph(); [1, 2, 3, 4].forEach(node => testGraph.addVertex(node)); [[1, 2], [1, 4], [2, 4]].forEach(edge => testGraph.addEdge(edge[0], edge[1])) }) test('#init', () => { expect(testGraph.getNeighbors(1)).toEqual([2, 4]); expect(testGraph.getNeighbors(2)).toEqual([1, 4]); expect(testGraph.getNeighbors(3)).toEqual([]); expect(testGraph.getNeighbors(4)).toEqual([1, 2]); }) // create test('#addVertex', () => { testGraph.add(5) expect(testGraph.getVertices()).toEqual([1, 2, 3, 4, 5]) }) test('#addEdge', () => { newEdge = [1, 3] testGraph.addEdge(newEdge[0], newEdge[1]) expect(testGraph.getEdges()).toEqual(new Set([ [1, 2], [1, 4], [2, 1], [2, 4], [4, 1], [4, 2], [1, 3], [3, 1], ])); }) // read test('#getNeighbors', () => { expect(testGraph.getNeighbors(1)).toEqual([2, 4]) expect(testGraph.getNeighbors(2)).toEqual([1, 4]) expect(testGraph.getNeighbors(3)).toEqual([]) expect(testGraph.getNeighbors(4)).toEqual([1, 2]) }) test.only('#getVertices', () => { expect(testGraph.getVertices()).toEqual([1, 2, 3, 4]) }) test('#getEdges', () => { expect(testGraph.getEdges()).toEqual(new Set([ [ 1, 2 ], [ 1, 4 ], [ 2, 1 ], [ 2, 4 ], [ 4, 1 ], [ 4, 2 ] ])); }) test('#findVertex', () => { expect(testGraph.findVertex(1)).toEqual(true) expect(testGraph.findVertex(5)).toEqual(false) }) test('#findEdge', () => { expect(testGraph.findEdge(1, 2)).toEqual(true) expect(testGraph.findEdge(1, 4)).toEqual(true) expect(testGraph.findEdge(2, 4)).toEqual(true) }) // update // destroy test('removeEdge', () => { testGraph.removeEdge(1, 2) expect(testGraph.getNeighbors(1)).toEqual([4]); expect(testGraph.getNeighbors(2)).toEqual([4]); }) test('removeVertex', () => { testGraph.removeVertex(1) expect(testGraph.getVertices()).toEqual([2, 3, 4]); expect(testGraph.getEdges()).toEqual(); })})Time complexityAdding a vertex: O(1) (constant time)Adding an edge: O(1) (constant time)Removing a vertex: O(V + E) (linear time, where V is the number of vertices and E is the number of edges)Removing an edge: O(1) (constant time)Finding a vertex: O(V) (linear time)Finding an edge: O(E) (linear time)Traversal AlgorithmI am going to use following graph to build traversal algorithms#mark33697{font-family:monospace;font-size:16px;fill:#333;}#mark33697 .error-icon{fill:#552222;}#mark33697 .error-text{fill:#552222;stroke:#552222;}#mark33697 .edge-thickness-normal{stroke-width:2px;}#mark33697 .edge-thickness-thick{stroke-width:3.5px;}#mark33697 .edge-pattern-solid{stroke-dasharray:0;}#mark33697 .edge-pattern-dashed{stroke-dasharray:3;}#mark33697 .edge-pattern-dotted{stroke-dasharray:2;}#mark33697 .marker{fill:#333333;stroke:#333333;}#mark33697 .marker.cross{stroke:#333333;}#mark33697 svg{font-family:monospace;font-size:16px;}#mark33697 .label{font-family:monospace;color:#333;}#mark33697 .cluster-label text{fill:#333;}#mark33697 .cluster-label span,#mark33697 p{color:#333;}#mark33697 .label text,#mark33697 span,#mark33697 p{fill:#333;color:#333;}#mark33697 .node rect,#mark33697 .node circle,#mark33697 .node ellipse,#mark33697 .node polygon,#mark33697 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark33697 .flowchart-label text{text-anchor:middle;}#mark33697 .node .label{text-align:center;}#mark33697 .node.clickable{cursor:pointer;}#mark33697 .arrowheadPath{fill:#333333;}#mark33697 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark33697 .flowchart-link{stroke:#333333;fill:none;}#mark33697 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark33697 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark33697 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark33697 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark33697 .cluster text{fill:#333;}#mark33697 .cluster span,#mark33697 p{color:#333;}#mark33697 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:monospace;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark33697 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark33697 :root{--mermaid-font-family:monospace;}ABCDEFGDFS (depth first search)PurposeFind paths between two verticesDetect cycles in a graphDetermine whether a graph is bipartiteConceptChoose a starting vertex in the graph.Visit the starting vertex and mark it as visited.Choose an unvisited neighbor of the current vertex.Move to the chosen neighbor and repeat steps 2 and 3 recursively.If there are no unvisited neighbors, backtrack to the previous vertex and choose the next unvisited neighbor (if any).Repeat steps 2-5 until all vertices have been visited or the desired condition is met.ExampleGiven the graph above, A -> B -> D -- backtrack to B -> E -> F -> C, so the result will be [A, B, D, E, F, C, G] (Intuition: video)Time complexity: O(V + E)Intuition: You need to add V nodes into set, which is O(V) and you need to loop through all neighbors, which is O(E)Code Exampleclass GraphTraversal extends Graph { depthFirstSearch(startVertex, visited = new Set()) { visited.add(startVertex); this.getNeighbors(startVertex).forEach(neighbor => { // O(E) if(!visited.has(neighbor)) { // O(V) this.depthFirstSearch(neighbor, visited) } }) return visited } ...}module.exports = GraphTraversal;Spec:const Graph = require('../examples/graph.js');describe('Graph', () => { beforeEach(() => { let testGraph = new Graph(); ['A', 'B', 'C', 'D', 'E', 'F', 'G'].forEach(node => testGraph.addVertex(node)); [['A', 'B'], ['A', 'C'], ['B', 'D'], ['B', 'E'], ['C', 'F'], ['E', 'F']].forEach(edge => testGraph.addEdge(edge[0], edge[1])) }) test('DFS', () => { expect(testGraph.depthFirstSearch('A')).toEqual(['A', 'B', 'D', 'E', 'F', 'C', 'G']); }) ...})BFS (breath first search)PurposeFind the shortest path between two nodes in an unweighted graphFind all the nodes that are at a certain distance from a given nodeCheck for the existence of a path between two nodes in a graphSolutionChoose a starting vertex in the graph.Enqueue the starting vertex into a queue and mark it as visited.While the queue is not empty, perform the following steps:Dequeue a vertex from the front of the queue.Visit the dequeued vertex.For each unvisited neighbor of the visited vertex, do the following:Enqueue the unvisited neighbor into the queue.Mark the neighbor as visited.Repeat steps 3 and 4 until the queue becomes empty.ExampleGiven the graph aboveThe queue and visited{queue: [A], visited: []}{queue: [], visited: [A]}{queue: [B, C], visited: [A]}{queue: [C], visited: [A, B]}{queue: [C, D, E], visited: [A, B]}{queue: [D, E], visited: [A, B, C]}{queue: [D, E, F], visited: [A, B, C]}{queue: [E, F], visited: [A, B, C, D]}{queue: [F], visited: [A, B, C, D, E]}{queue: [F], visited: [A, B, C, D, E, F]}Intuition: videoTime complexity: O(V + E)Given the result in example section, we can see that it will enqueue all nodes to visited array once and enqueue all nodes with edges to other nodes and not visited once, making the complexity to be V + Ecode exampleclass GraphTraversal extends Graph { breadthFirstSearch(startingVertex) { const queue = [startingVertex]; const visited = new Set([startingVertex]); while (queue.length) { const currentVertex = queue.shift(); const neighbors = this.getNeighbors(currentVertex); for (let neighbor of neighbors) { if (!visited.has(neighbor)) { visited.add(neighbor); queue.push(neighbor); } } } return visited; } ...}module.exports = GraphTraversal;specconst Graph = require('../examples/graph.js');describe('Graph', () => { beforeEach(() => { let testGraph = new Graph(); ['A', 'B', 'C', 'D', 'E', 'F', 'G'].forEach(node => testGraph.addVertex(node)); [['A', 'B'], ['A', 'C'], ['B', 'D'], ['B', 'E'], ['C', 'F'], ['E', 'F']].forEach(edge => testGraph.addEdge(edge[0], edge[1])) }) ... test('BFS', () => { expect(testGraph.breadthFirstSearch('A')).toEqual(new Set(['A', 'B', 'C', 'D', 'E', 'F'])); })})DFS vs BFSMemory efficiency: DFS > BFS because DFS do not need another queue to store nodes going to be visited.Detecting cycles: DFS > BFS because DFS will go deeper first, which will return to a visited node on a route first, compared to BFS.Find shortest path: DFS < BFS because BFS does level-by-level exploration. When we find a target nodes, we can stop the exploration and return the path from a node to target node.Route Between NodesProblem: Given a directed graph, design an algorithm to find out whether there is a route between two nodes.ExampleNormal: I think I do not need more information and I will use DFS.Edge: What if there is route between two node but the direction is wrong? If the graph is A -> B -> C, then there is route from A to C but not C to A.Time complexity: It at most need to traverse all the nodes, so the time complexity is O(V+E)Codefunction routeBetweenNodes (graph, start, end) { if (start === end) { return true } let nextNodes = graph.getNeighbors(start) for (let i = 0; i < nextNodes.length; i ++) { if (routeBetweenNodes(graph, nextNodes[i], end)) { return true } } return false}module.exports = routeBetweenNodesTestVisualize#mark55324{font-family:monospace;font-size:16px;fill:#333;}#mark55324 .error-icon{fill:#552222;}#mark55324 .error-text{fill:#552222;stroke:#552222;}#mark55324 .edge-thickness-normal{stroke-width:2px;}#mark55324 .edge-thickness-thick{stroke-width:3.5px;}#mark55324 .edge-pattern-solid{stroke-dasharray:0;}#mark55324 .edge-pattern-dashed{stroke-dasharray:3;}#mark55324 .edge-pattern-dotted{stroke-dasharray:2;}#mark55324 .marker{fill:#333333;stroke:#333333;}#mark55324 .marker.cross{stroke:#333333;}#mark55324 svg{font-family:monospace;font-size:16px;}#mark55324 .label{font-family:monospace;color:#333;}#mark55324 .cluster-label text{fill:#333;}#mark55324 .cluster-label span,#mark55324 p{color:#333;}#mark55324 .label text,#mark55324 span,#mark55324 p{fill:#333;color:#333;}#mark55324 .node rect,#mark55324 .node circle,#mark55324 .node ellipse,#mark55324 .node polygon,#mark55324 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark55324 .flowchart-label text{text-anchor:middle;}#mark55324 .node .label{text-align:center;}#mark55324 .node.clickable{cursor:pointer;}#mark55324 .arrowheadPath{fill:#333333;}#mark55324 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark55324 .flowchart-link{stroke:#333333;fill:none;}#mark55324 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark55324 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark55324 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark55324 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark55324 .cluster text{fill:#333;}#mark55324 .cluster span,#mark55324 p{color:#333;}#mark55324 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:monospace;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark55324 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark55324 :root{--mermaid-font-family:monospace;}ABCDEFGCodeconst DirectedGraph = require('../examples/directed-graph.js')const routeBetweenNodes = require('../examples/route-between-nodes.js')describe('Route Between Nodes', () => { let testGraph beforeEach(() => { testGraph = new DirectedGraph(); ['A', 'B', 'C', 'D', 'E', 'F', 'G'].forEach((node) => { testGraph.addVertex(node); }); [['A', 'B'], ['B', 'D'], ['B', 'E'], ['E', 'F'], ['A', 'C'], ['C', 'F']].forEach(edge => testGraph.addEdge(edge[0], edge[1])) }) test('#', () => { expect(routeBetweenNodes(testGraph, 'A', 'F')).toEqual(true) expect(routeBetweenNodes(testGraph, 'C', 'E')).toEqual(false) })})Conclusion: Time complexity is O(V + E) because I will only visit those nodes once. GPT told me I should use BFS.Build OrderQuestion: You are given a list of projects and a list of dependencies (which is a list of pairs of projects, where the second project is dependent on the first project). Ail of a project's dependencies must be built before the project is. Find a build order that will allow the projects to be built. If there is no valid build order, return an error.ExampleOk, the list of projects is the vertices in a graph and the dependencies is the edges. I need to use BFS because after one project is built the other projects around this project can be build as well.But the problem is how can I find the root if the graph => I think I need to find the node that is less dependent on other project first.Codeconst DirectedGraph = require(\"../examples/directed-graph\")function buildOrder(projects, dependencies) { let graph = new DirectedGraph() projects.forEach((project) => { graph.addVertex(project) }) dependencies.forEach((dependency) => { graph.addEdge(dependency[0], dependency[1]) }) const findStarts = (projects, dependencies) => { dependent = dependencies.map((d) => {return d[1]}) result = projects.filter((element) => !dependent.includes(element)) return result } starts = findStarts(projects, dependencies) for(let i = 0; i < starts.length; i++) { let start = starts[i] const queue = [start] const visits = new Set([start]) while(queue.length) { // this is the important step of BFS const currentVertex = queue.shift() const neighbors = graph.getNeighbors(currentVertex) for(let neighbor of neighbors) { if(!visits.has(neighbor)) { queue.push(neighbor) visits.add(neighbor) } } } for(let i = 0; i < starts.length; i++) { // remember to use let... visits.add(starts[i]) } if(projects.length === visits.size) { console.log(visits) return [...visits] } } return false}module.exports = buildOrderTestconst buildOrder = require('../examples/build-order.js')describe('build order', () => { let projects = ['a', 'b', 'c', 'd', 'e', 'f'] let dependencies = [['a', 'd'], ['f', 'b'], ['b', 'd'], ['f', 'a'], ['d', 'c']] test('#', () => { expect(buildOrder(projects, dependencies)).toEqual(['f', 'b', 'a', 'd', 'c', 'e']) })})What?MazeTry to find the shortest path in maze with DFSRepresent maze as a graph, each cell is a node and the neighboring cells are connected by edgesUse a depth-first search algorithm to explore all possible paths from the starting cell to the exit cell. We can mark each cell as visited as we explore the maze and keep track of the shortest path we've found so far. Once we reach the exit cell, we compare the length of the path we've found to the shortest path so far and update it if the new path is shorter.This approach can be optimized using techniques such as backtracking and memoization to avoid exploring paths that cannot lead to the shortest path.Code example:ReferenceGraph Data Structure in Javascript10 Graph Algorithms Visually Explained","url":"/blog/software/dsa/graph"},{"title":"(dsa) Stack","content":"(dsa) StackPurposeLearning about stacks is essential for understanding how function calls and recursion work in programming languages, as well as for organizing and managing data efficiently.ConceptImage SourceStack uses mechanism of first in last out (FILO), we can only add or pop the top element.Coding example:class Stack { constructor() { this.items = []; } push(element) { this.items.push(element); } pop() { if (this.items.length === 0) { return \"Underflow\"; } return this.items.pop(); } peek() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } size() { return this.items.length; } print() { console.log(this.items.toString()); }}specconst Stack = require('../examples/stack.js');describe('Stack', () => { describe('with item', () => { let testStack; beforeEach(() => { testStack = new Stack(); const values = [1, 74, 888, 62, 33]; for(let i = 0; i < values.length; i++){ testStack.push(values[i]); } }); test('#push', () => { testStack.push(0); expect(testStack.print()).toEqual([ 1, 74, 888, 62, 33, 0 ]); }); test('#pop', () => { testStack.pop() expect(testStack.print()).toEqual([ 1, 74, 888, 62 ]); }) test('#peek', () => { expect(testStack.peek()).toEqual(33); }) test('#isEmpty', () => { expect(testStack.isEmpty()).toEqual(false); }) test('#size', () => { expect(testStack.size()).toEqual(testStack.items.length); }) }) describe('no item', () => { let testStack = new Stack(); test('#pop', () => { expect(testStack.pop()).toEqual(\"Underflow\"); }) test('#isEmpty', () => { expect(testStack.isEmpty()).toEqual(true); }) })});Time complexityCreate an item: O(1)Simply add an item on the stack.Read an item: O(1)We can only access the top, so the time complexity of this operation is O(1), which is constant time complexity.Update an item: O(1)Again, we can only access the top, so the time complexity of this operation is O(1).Delete an item: O(1)Again, we can only access the top, so the time complexity of this operation is O(1).Three in OneProblem: Use a single array to implement three stacksExample:// array length = 15[ 1, 2, 3, 4, null 1, 2, 3, null, null 1, null, null, null, null]// push(3, 4)[ 1, 2, 3, 4, null 1, 2, 3, null, null 1, 4, null, null, null // it will push 3 to the third sub-array]// pop(3)[ 1, 2, 3, 4, null 1, 2, 3, null, null null, null, null, null, null // it will pop out the element in third sub array]Implement (just divide array into three portion)class threeStacksInOneArray { // divide array equally // all start from 1, whichStack and position constructor(arrayLength) { this.elements = new Array(arrayLength).fill(null); this.starts = [0, Math.round(arrayLength / 3), Math.round(arrayLength / 3) * 2] this.ends = [Math.round(arrayLength / 3) - 1, Math.round(arrayLength / 3) * 2 - 1, arrayLength - 1] this.addAts = [0, Math.round(arrayLength / 3), Math.round(arrayLength / 3) * 2] } push(whichStack, value) { if (this.addAts[whichStack] == this.ends[whichStack]) { return `no more space for ${whichStack + 1}th stack` } this.elements[this.addAts[whichStack]] = value this.addAts[whichStack] += 1 } pop(whichStack) { if (this.addAts[whichStack] == this.ends[whichStack]) { return `no more value to pop in ${whichStack + 1}th stack` } this.elements[this.addAts[whichStack] - 1] = null this.addAts[whichStack] -= 1 } peek(whichStack) { return this.elements[this.addAts[whichStack - 1] - 1] } isEmpty(whichStack) { const start = this.starts[whichStack - 1] const end = this.ends[whichStack - 1] const subStack = [] for (let i = start; i < end; i++) { subStack.push(this.elements[i]); } return subStack.every(element => { return element === null; }) } size(whichStack) { const start = this.starts[whichStack - 1] const end = this.ends[whichStack - 1] let result = 0 for (let i = start; i < end; i++) { if (this.elements[i] !== null) { result += 1 } } return result } print(whichStack) { const start = this.starts[whichStack - 1] const end = this.ends[whichStack - 1] const subStack = [] for (let i = start; i <= end; i++) { subStack.push(this.elements[i]); } return subStack }}module.exports = threeStacksInOneArray;specconst ThreeStackInOneArray = require('../examples/three_stacks_in_one_array.js');describe('ThreeStackInOneArray', () => { let testStack; let totalLength = 17; let data = [ [1, 74], [888, 62, 33], [83, 44], ] beforeEach(() => { testStack = new ThreeStackInOneArray(totalLength); for(let i = 0; i < data.length; i++) { for (let j = 0; j < data[i].length; j ++) { testStack.push(i, data[i][j]); } } }); test('#init', () => { expect(testStack.elements).toEqual([ 1, 74, null, null, null, null, 888, 62, 33, null, null, null, 83, 44, null, null, null, ]) expect(testStack.addAts).toEqual([2, 9, 14]) expect(testStack.ends).toEqual([5, 11, 16]) }) test('#push', () => { testStack.push(0, 4); expect(testStack.elements).toEqual([ 1, 74, 4, null, null, null, 888, 62, 33, null, null, null, 83, 44, null, null, null, ]); expect(testStack.addAts).toEqual([3, 9, 14]) }); test('#pop', () => { testStack.pop(1); expect(testStack.elements).toEqual([ 1, 74, null, null, null, null, 888, 62, null, null, null, null, 83, 44, null, null, null, ]); expect(testStack.addAts).toEqual([2, 8, 14]) }) test('#peek', () => { expect(testStack.peek(1)).toEqual(74) expect(testStack.peek(2)).toEqual(33) expect(testStack.peek(3)).toEqual(44) }) test('#size', () => { expect(testStack.size(1)).toEqual(2) expect(testStack.size(2)).toEqual(3) expect(testStack.size(3)).toEqual(2) }) test('#print', () => { expect(testStack.print(1)).toEqual([1, 74, null, null, null, null]) expect(testStack.print(2)).toEqual([888, 62, 33, null, null, null]) expect(testStack.print(3)).toEqual([83, 44, null, null, null]) }) describe('with empty sub stack', () => { let testStack; let totalLength = 17; let data = [ [1, 74], [888, 62, 33], [], ] beforeEach(() => { testStack = new ThreeStackInOneArray(totalLength); for(let i = 0; i < data.length; i++) { for (let j = 0; j < data[i].length; j ++) { testStack.push(i, data[i][j]); } } }); test('#isEmpty', () => { expect(testStack.isEmpty(1)).toEqual(false) expect(testStack.isEmpty(2)).toEqual(false) expect(testStack.isEmpty(3)).toEqual(true) }) })});Generalize (TBC)Code exampleclass KStacksInOneArray { constructor(k, n) { // k means number of stacks and n means length of array this.k = k this.elements = new Array(n).fill(null); this.starts = []; for (let i = 0; i < k; i++) { this.starts.push(Math.ceil(n/k) * i) } this.ends = []; for (let i = 0; i < k; i++) { if (i == (k - 1)) { this.ends.push(n - 1) } else { this.ends.push(this.starts[i] + Math.floor(n/k)) } } } push(kth, value) { // kth = 0 -> first stack in array ... if (kth > this.k) { console.log('no stack') return } if (this.starts[kth - 1] == this.ends) { console.log('no more space') return } this.elements[this.starts[kth - 1]] = value this.starts[kth - 1] += 1 } pop(kth) { if((this.elements[this.starts[kth - 1]] === undefined) || (this.elements[this.starts[kth - 1] - 1] === null)) { console.log('no elements') return } else { this.elements[this.starts[kth - 1] - 1] = null this.starts[kth - 1] -= 1 } }}spec (TBC)usagelet test = new KStacksInOneArray(3, 17);test.push(3, 16)test.pop(3)console.log(test.starts)console.log(test.elements)more general: The first approach did not use the space in array efficiently because we cannot put more data into an full stack even if there are space in other stacks. (TBC)Stack MinProblem: How would you design a stack which, in addition to push and pop, has a function min which returns the minimum element? Push, pop and min should ail operate in 0 ( 1 ) time.Example: Stack [3, 1, 9, 8] => return 1Edge Case: Seems noCode example:class StackMin { constructor() { this.items = [] this.min } push(value) { } pop() { } min() { }}Test:describe('StackMin', () => { let testStack; beforeEach(() => { testStack = new Stack(); const values = [74, 1, 3, 20, 888, 62, 33]; for(let i = 0; i < values.length; i++){ testStack.push(values[i]); } }); test('#min', () => { })})Stack of PlatesQuestion: Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure SetOfStacks that mimics this. SetOfStacks should be composed of several stacks and should create a new stack once the previous one exceeds capacity. SetOfStacks .push() and SetOfStacks .pop() should behave identically to a single stack (that is, pop( ) should return the same values as it would if there were just a single stack).Example:I think there is only one stack to be created when previous one exceeds capacity.Also, I think I can use index to check whether new one is empty so that I can pop.Also, I think I can use index to tell program which stack to push value.Codeclass SetOfStacks { constructor(capacity) { this.capacity = capacity this.stacks = [] this.currentStack = null } this.push(value) { if(this.currentStack === null) { this.currentStack = new Stack() this.currentStack.push(value) } else if(this.currentStack.size() >= this.capacity) { this.stacks.push(this.currentStack) this.currentStack = new Stack() } else { this.currentStack.push(value) } } this.pop(value) { if(this.currentStack === null && this.stacks.length === 0) { return 'no element' } else if(this.currentStack.length === 0) { this.currentStack = this.stacks.pop() this.currentStack.pop() } else { this.currentStack.pop() } }}Testdescribe('set of stacks', () => { let setOfStacks describe('capacity === 3', () => { setOfStacks = new SetOfStacks(3) describe('existed elements = [1, 2, 3, 4, 5, 6]', () => { beforeEach(() => { [1, 2, 3, 4, 5, 6].forEach((element) => { setOfStacks.push(element) }) }) test('#push 7', () => { setOfStacks.push(7) expect(setOfStacks.stacks.length).toEqual(3) }) }) describe('three stacks but last stack is empty', () => { beforeEach(() => { [1, 2, 3, 4, 5, 6, 7].forEach((element) => { setOfStacks.push(element) }) setOfStacks.pop() }) test('#pop', () => { expect(setOfStacks.pop()).toEqual(6) expect(setOfStacks.stacks.length).toEqual(2) }) }) describe('existed elements is none', () => { test('#pop', () => { expect(setOfStacks.pop()).toEqual('no element') }) }) })})Sort StackQuestion: Write a program to sort a stack such that the smallest items are on the top. You can use an additional temporary stack, but you may not copy the elements into any other data structure (such as an array). The stack supports the following operations: push, pop, peek, and is Empty.ExampleCan only use additional temporary stackCannot copy elementsCan use a placeholder to hold a value temporaryCodefunction sortStack(stack) { // Input = [3, 1, 2, 4] // Output = [4, 3, 2, 1] const additionalStack = new Stack() let topPlaceholder while(!stack.empty()) { topPlaceholder = stack.pop() while(!additionalStack.empty() && additionalStack.peek() > topPlaceholder) { stack.push(additionalStack.pop()) } additionalStack.push(topPlaceholder) console.log('==========') console.log(stack) console.log(additionalStack) // this is really hard to come out the idea // the idea is to compare the size of the placeholder, if larger than placeholder, move the larger items from additional to the stack and then put the placeholder to the additional stack. // Actually, it is trying to make the additional stack from small to large and make the stack from large to small. Each round it tries to move an item to additional stack and before it puts the item into, if there is any item larger than this placeholder, move them to the stack first. } while (!additionalStack.isEmpty()) { stack.push(additionalStack.pop()) } return stack}Testdescribe('sort stack', () => { // bottom -> top // Input = [3, 1, 2, 4] // Output = [4, 3, 2, 1] test('#', () => { let stack = new Stack() [3, 1, 2, 4].forEach((item) => {stack.push(item)}) expect(sortStack(stack).items).toEqual([4, 3, 2, 1]) })})Real world exampleReferencecracking the coding interviewThree In One: How to Implement 3 Stacks Using 1 Array","url":"/blog/software/dsa/stack"},{"title":"(dsa) Queue","content":"(dsa) QueuePurposeLearning about queues is important in computer science and programming as it helps in managing data and organizing tasks efficiently using the First-In-First-Out (FIFO) principle.ConceptVisualizationSourceCodeImplementationclass Queue { constructor() { this.items = []; } enqueue(element) { this.items.push(element); } dequeue() { if (this.isEmpty()) { return \"Queue is empty\"; } return this.items.shift(); } peek() { if (this.isEmpty()) { return \"Queue is empty\"; } return this.items[0]; } isEmpty() { return this.items.length === 0; } size() { return this.items.length; }}Specconst Queue = require('../examples/queue.js');describe('Queue', () => { let testQueue; beforeEach(() => { testQueue = new Queue(); const values = [1, 74, 888, 62, 33]; for(let i = 0; i < values.length; i++){ testQueue.enqueue(values[i]); } }); test('#init', () => { expect(testQueue.print()).toEqual([1, 74, 888, 62, 33]) }) test('#enqueue', () => { testQueue.enqueue(0); expect(testQueue.print()).toEqual([1, 74, 888, 62, 33, 0]); }); test('#dequeue', () => { // first in is 1 testQueue.dequeue(); expect(testQueue.print()).toEqual([74, 888, 62, 33]); }) test('#peek', () => { expect(testQueue.peek()).toEqual(1); }); test('#isEmpty', () => { expect(testQueue.isEmpty()).toEqual(false); }) test('#size', () => { expect(testQueue.size()).toEqual(5); })});Time complexityCreate an item: O(1), The enqueue method will concatenate item on the last without shifting elements, so the complexity will not increase when the number of elements increases.Read an item: O(1), The read method can only read the front element of the queue, so the complexity will not increase when the number of elements increases.Update an item: O(n), It is not normal to have update operation in queue. We achieve by dequeuing the elements and then enqueuing back. As a result, the time complexity i s O(n) on worst case.Delete an item: O(1) because when removing the last element, there is no need to shift or modify any other elements, making it independent of the queue's size.Queue via StacksProblem: implement a MyQueue class which implements a queue using two stacks.Information: We just need to accomplish the FIFO effect with two LIFO.coding example:const Stack = require('../../stack/examples/stack.js')class QueueViaStacks { // FIFO constructor() { this.stackOne = new Stack(); this.stackTwo = new Stack(); } enqueue(element) { this.stackOne.push(element); } dequeue() { for (let i = 0; i < length; i++) { this.stackTwo.push(this.stackOne.pop()) } return this.stackTwo.pop() }}module.exports = QueueViaStacksjestconst QueueViaStacks = require('../examples/queue_via_stacks.js');describe('QueueViaStacks', () => { let testQueueViaStacks; beforeEach(() => { testQueueViaStacks = new QueueViaStacks(); const values = [1, 74, 888, 62, 33]; for(let i = 0; i < values.length; i++){ testQueueViaStacks.enqueue(values[i]); } }); test('#FIFO', () => { // TBC expect(testQueueViaStacks.dequeue()).toEqual(1) })});Animal ShelterProblem:Shelter has dogs and catsPeople can only adopt the oldest animal based on arrival timePeople can choose type (dog or cat)You can use linkedlistMethods: Enqueue, DequeueAny, DequeueDog, and DequeueCatExample:['d1', 'd2', 'c1', 'c2', 'd3', 'c3'] ==DequeueAny=> ['d2', 'c1', 'c2', 'd3', 'c3']['d1', 'd2', 'c1', 'c2', 'd3', 'c3'] ==DequeueDog=> ['d2', 'c1', 'c2','d3', 'c3']['d1', 'd2', 'c1', 'c2', 'd3', 'c3'] ==DequeueCat=> ['d1', 'd2', 'c2', 'd3', 'c3']Code example:class Node { constructor(value, type, next = null) { this.value = value; this.type = type; this.next = next; }}class AnimalShelter { constructor() { this.head = null; } enqueue(value, type) { if(this.head === null) { this.head = new Node(value, type) } else { const lastNode = this.traverseToLast() lastNode.next = new Node(value, type) } } dequeueAny() { this.head = this.head.next } dequeueDog() { let currentNode = this.head let preNode if(currentNode.type === 'dog') { this.head = this.head.next return currentNode } while(currentNode.type !== 'dog') { preNode = currentNode currentNode = currentNode.next } preNode.next = currentNode.next return currentNode } dequeueCat() { let currentNode = this.head let preNode if(currentNode.type === 'cat') { this.head = this.head.next return currentNode } while(currentNode.type !== 'cat') { preNode = currentNode currentNode = currentNode.next } preNode.next = currentNode.next return currentNode } dequeueAny() { this.head = this.head.next return this.head } printList() { const result = [] let currentNode = this.head while(currentNode) { result.push(currentNode.value) currentNode = currentNode.next } return result } traverseToLast() { let currentNode = this.head; for (let i = 0; i < Infinity; i++) { if (currentNode.next !== null) { currentNode = currentNode.next; } else { return currentNode } } return currentNode }}module.exports = AnimalShelterTest:const AnimalShelter = require('../examples/animal_shelter.js')describe('AnimalShelter', () => { beforeEach(() => { testAnimalShelter = new AnimalShelter(); const values = [ {id: 'd1', type: 'dog'}, {id: 'd2', type: 'dog'}, {id: 'c1', type: 'cat'}, {id: 'c2', type: 'cat'}, {id: 'd3', type: 'dog'}, {id: 'c3', type: 'cat'}, ]; for(let i = 0; i < values.length; i++){ testAnimalShelter.enqueue(values[i]['id'], values[i]['type']); } }); test('#enqueue', () => { expect(testAnimalShelter.printList()).toEqual(['d1', 'd2', 'c1', 'c2', 'd3', 'c3']) }); test('#dequeueAny', () => { testAnimalShelter.dequeueAny() expect(testAnimalShelter.printList()).toEqual(['d2', 'c1', 'c2', 'd3', 'c3']) }) test('#dequeueCat', () => { testAnimalShelter.dequeueCat() expect(testAnimalShelter.printList()).toEqual(['d1', 'd2', 'c2', 'd3', 'c3']) }) test('#dequeueDog', () => { testAnimalShelter.dequeueDog() expect(testAnimalShelter.printList()).toEqual(['d2', 'c1', 'c2', 'd3', 'c3']) })});Sliding Window MaximumProblem: Given an array of integers and a window size k, the problem is to find the maximum element in each window of size k as it slides from left to right through the array.ExampleInput: [1, 3, -1, -3, 5, 3, 6, 7]; window size = 3Output: [3, 3, 5, 5, 6, 7] because 3 out of [1, 3, -1], 3 out of [3, -1, -3], ...First try (brute force)function SlideWindowMaximum(array, window_size) { queue = [array[0], array[1], array[2]] // use slice (2023/07/05) for(i = 0; i < array.length; i++) { }}Real world exampleTBCReference","url":"/blog/software/dsa/queue"},{"title":"(dsa) Heap","content":"(dsa) HeapPurposeHeaps are necessary because they provide an efficient way to manage priority-based operations, such as retrieving the minimum or maximum element, which is valuable in various applications like scheduling, graph algorithms, and priority queues.ConceptAlthough heap is a complete binary tree, we usually use array to construct heap because of efficient memory usage, sequential access, cache efficiency, simplicity of indexing, and improved space efficiency.Min HeapDefinition: A min heap is a complete binary tree where the value of each node is smaller than or equal to the values of its child nodes, with the minimum value located at the root node.Visualization#mark86914{font-family:monospace;font-size:16px;fill:#333;}#mark86914 .error-icon{fill:#552222;}#mark86914 .error-text{fill:#552222;stroke:#552222;}#mark86914 .edge-thickness-normal{stroke-width:2px;}#mark86914 .edge-thickness-thick{stroke-width:3.5px;}#mark86914 .edge-pattern-solid{stroke-dasharray:0;}#mark86914 .edge-pattern-dashed{stroke-dasharray:3;}#mark86914 .edge-pattern-dotted{stroke-dasharray:2;}#mark86914 .marker{fill:#333333;stroke:#333333;}#mark86914 .marker.cross{stroke:#333333;}#mark86914 svg{font-family:monospace;font-size:16px;}#mark86914 .label{font-family:monospace;color:#333;}#mark86914 .cluster-label text{fill:#333;}#mark86914 .cluster-label span,#mark86914 p{color:#333;}#mark86914 .label text,#mark86914 span,#mark86914 p{fill:#333;color:#333;}#mark86914 .node rect,#mark86914 .node circle,#mark86914 .node ellipse,#mark86914 .node polygon,#mark86914 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark86914 .flowchart-label text{text-anchor:middle;}#mark86914 .node .label{text-align:center;}#mark86914 .node.clickable{cursor:pointer;}#mark86914 .arrowheadPath{fill:#333333;}#mark86914 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark86914 .flowchart-link{stroke:#333333;fill:none;}#mark86914 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark86914 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark86914 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark86914 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark86914 .cluster text{fill:#333;}#mark86914 .cluster span,#mark86914 p{color:#333;}#mark86914 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:monospace;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark86914 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark86914 :root{--mermaid-font-family:monospace;}10152018172530Code exampleclass MinHeap { constructor(values) { this.values = values this.heapify() } // create insert(value) { this.values.push(value) this.heapify() } // read findMin() { return this.values[0] } // update update(value, index) { this.values[index] = value this.heapify() return this.values } // destroy delete() { this.values.shift() this.heapify() } heapify() { // bottom up approach for(let i = this.values.length - 1; i >= 0; i--) { const leftChildIndex = i * 2 + 1 const rightChildIndex = i * 2 + 2 let smallestIndex = i if(this.values[i] > this.values[leftChildIndex]) { smallestIndex = leftChildIndex } if(this.values[smallestIndex] > this.values[rightChildIndex]) { smallestIndex = rightChildIndex } if(smallestIndex !== i) { const tmp = this.values[i] this.values[i] = this.values[smallestIndex] this.values[smallestIndex] = tmp this.heapify(leftChildIndex) this.heapify(rightChildIndex) } } }}module.exports = MinHeapSpecMinHeap = require('./min_heap.js')describe('MinHeap', () => { let heap = new MinHeap([5, 12, 8, 3, 9, 7]) // init test('#new', () => { expect(heap.values).toEqual([3, 5, 7, 12, 9, 8]) }) // create test('#insert', () => { heap.insert(4) expect(heap.values).toEqual([3, 5, 4, 12, 9, 8, 7]) }) // read test('findMin', () => { expect(heap.findMin()).toEqual(3) }) // update test('#update', () => { heap.update(6, 3) expect(heap.values).toEqual([3, 5, 7, 6, 9, 8]) }) // destroy test.only('#delete', () => { heap.delete() expect(heap.values).toEqual([5, 7, 12, 9, 8]) })})Max HeapDefinition: A max heap is a complete binary tree where the value of each node is greater than or equal to the values of its child nodes, with the maximum value located at the root node.Visualization#mark3208{font-family:monospace;font-size:16px;fill:#333;}#mark3208 .error-icon{fill:#552222;}#mark3208 .error-text{fill:#552222;stroke:#552222;}#mark3208 .edge-thickness-normal{stroke-width:2px;}#mark3208 .edge-thickness-thick{stroke-width:3.5px;}#mark3208 .edge-pattern-solid{stroke-dasharray:0;}#mark3208 .edge-pattern-dashed{stroke-dasharray:3;}#mark3208 .edge-pattern-dotted{stroke-dasharray:2;}#mark3208 .marker{fill:#333333;stroke:#333333;}#mark3208 .marker.cross{stroke:#333333;}#mark3208 svg{font-family:monospace;font-size:16px;}#mark3208 .label{font-family:monospace;color:#333;}#mark3208 .cluster-label text{fill:#333;}#mark3208 .cluster-label span,#mark3208 p{color:#333;}#mark3208 .label text,#mark3208 span,#mark3208 p{fill:#333;color:#333;}#mark3208 .node rect,#mark3208 .node circle,#mark3208 .node ellipse,#mark3208 .node polygon,#mark3208 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark3208 .flowchart-label text{text-anchor:middle;}#mark3208 .node .label{text-align:center;}#mark3208 .node.clickable{cursor:pointer;}#mark3208 .arrowheadPath{fill:#333333;}#mark3208 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark3208 .flowchart-link{stroke:#333333;fill:none;}#mark3208 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark3208 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark3208 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark3208 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark3208 .cluster text{fill:#333;}#mark3208 .cluster span,#mark3208 p{color:#333;}#mark3208 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:monospace;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark3208 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark3208 :root{--mermaid-font-family:monospace;}20181510128756Code exampleclass MaxHeap { constructor(values) { this.heap = values; } // create insert(value) { this.heap.unshift(value) this.heapify() } // read findMax() { return this.heap[0] } values() { return this.heap } // update update(value, index) { this.heap[index] = value this.heapify() } // destroy delete() { // In max heap, we usually remove the maximum value this.heap.shift() this.heapify() } heapify(i = 0) { const leftChildIndex = i * 2 + 1 const rightChildIndex = i * 2 + 2 if (i > this.heap.length) return let largest = i if (leftChildIndex < this.heap.length && this.heap[leftChildIndex] > this.heap[largest]) { largest = leftChildIndex } if (rightChildIndex < this.heap.length && this.heap[rightChildIndex] > this.heap[largest]) { largest = rightChildIndex } if (largest !== i) { // Swap the current node with the largest child const temp = this.heap[i]; this.heap[i] = this.heap[largest]; this.heap[largest] = temp; } // Recursively heapify the affected child's subtree this.heapify(leftChildIndex); this.heapify(rightChildIndex); }}module.exports = MaxHeapSpecconst MaxHeap = require('./max_heap.js')describe('Max Heap', () => { let heap beforeEach(async () => { heap = new MaxHeap([20, 9, 15, 5, 7, 10]) }); test('insert', () => { heap.insert(3) expect(heap.values()).toEqual([20, 15, 10, 3, 5, 7, 9]) }) test('update', () => { // check next time. It's wrong heap.update(3, 2) // [20, 9, 3, 5, 7, 10] expect(heap.values()).toEqual([20, 9, 10, 5, 7, 3]) }) test('delete', () => { heap.delete() expect(heap.values()).toEqual([15, 10, 5, 7, 9]) }) test('findMax', () => { expect(heap.findMax()).toEqual(20) }) test('heapify', () => { let randomHeap = new MaxHeap([10, 20, 5, 15, 9, 7]) randomHeap.heapify() expect(randomHeap.values()).toEqual([20, 15, 7, 10, 9, 5]) })})ReferenceHeaps in 3 minutes — Intro","url":"/blog/software/dsa/heap"},{"title":"(dsa) Tries","content":"(dsa) TriesPurposeTries are a useful data structure for efficiently storing and searching for strings in a large dataset.ConceptSuppose we have a set of strings {bear, bell, bid, bull, stock, stop}. We can build a trie for this set of strings as follows:#mark76211{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark76211 .error-icon{fill:#552222;}#mark76211 .error-text{fill:#552222;stroke:#552222;}#mark76211 .edge-thickness-normal{stroke-width:2px;}#mark76211 .edge-thickness-thick{stroke-width:3.5px;}#mark76211 .edge-pattern-solid{stroke-dasharray:0;}#mark76211 .edge-pattern-dashed{stroke-dasharray:3;}#mark76211 .edge-pattern-dotted{stroke-dasharray:2;}#mark76211 .marker{fill:#333333;stroke:#333333;}#mark76211 .marker.cross{stroke:#333333;}#mark76211 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark76211 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark76211 .cluster-label text{fill:#333;}#mark76211 .cluster-label span,#mark76211 p{color:#333;}#mark76211 .label text,#mark76211 span,#mark76211 p{fill:#333;color:#333;}#mark76211 .node rect,#mark76211 .node circle,#mark76211 .node ellipse,#mark76211 .node polygon,#mark76211 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark76211 .flowchart-label text{text-anchor:middle;}#mark76211 .node .label{text-align:center;}#mark76211 .node.clickable{cursor:pointer;}#mark76211 .arrowheadPath{fill:#333333;}#mark76211 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark76211 .flowchart-link{stroke:#333333;fill:none;}#mark76211 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark76211 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark76211 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark76211 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark76211 .cluster text{fill:#333;}#mark76211 .cluster span,#mark76211 p{color:#333;}#mark76211 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark76211 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark76211 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}bseiutaldlorllcpkrootcodeclass TrieNode { constructor() { this.children = {}; this.isEndOfWord = false; }}class Trie { constructor() { this.root = new TrieNode(); } // create insert(word) { let node = this.root; for (let i = 0; i < word.length; i++) { const char = word[i]; if (!node.children[char]) { node.children[char] = new TrieNode(); } node = node.children[char]; } node.isEndOfWord = true; } // read search(word) { let node = this.root; for (let i = 0; i < word.length; i++) { const char = word[i]; if (!node.children[char]) { return false; } node = node.children[char]; } return node.isEndOfWord; } // update // It is not normal to have update method in tries // destroy delete(word) { let node = this.root let nodes = [] for (let i = 0; i < word.length; i++) { const char = word[i] if (!node.children[char]) { return } node = node.children[char] nodes.push(node) } if(!node.isEndOfWord) { return } for (let i = nodes.length - 2; i >= 0; i--) { if (Object.keys(nodes[i].children).length > 1) { continue } else { delete nodes[i].children[word[i + 1]] // remove the specific children of that character } } node.isEndOfWord = false; }}module.exports = TrieTries are not design for frequent updatesSpecconst Trie = require('../examples/trie.js')describe('Trie', () => { let trie = new Trie() beforeEach(() => { trie.insert('bear') trie.insert('bell') }) it('should insert words', () => { expect(trie.search('bear')).toEqual(true) expect(trie.search('bell')).toEqual(true) }) it('should delete a word', () => { trie.delete('bell') expect(trie.search('bell')).toEqual(false) expect(trie.search('bear')).toEqual(true) })})Time complexity (Because tries are usually used for wording, I will discuss the time complexity of CRUD of a wording)Create: Given a tries, to create a word in tries, we need to traverse all the letters in the given word and because all the children of a node lay in a hash, the time complexity to check whether it exists in children is O(1). Then the time complexity will be O(n); that is, traverse all the letters and insert it into the tries.Read: Again, to read a wording in tries, we need to traverse all the letter in the given tries and it is O(n).Delete: It will check whether this word exists in tries and then remove the nodes with only one specific children of corresponding letters. Because the reading of hash is O(1), the time complexity of removing a node is O(n). (Or you can say it is O(n + n) since we need to traverse the tries first)Update: You can think update = delete and then create, so the time complexity is also O(n).Real World ExampleReal world example: Trie for melodyclass MelodyTrie { constructor() { this.root = {}; } insert(melody) { let node = this.root; for (let i = 0; i < melody.length; i++) { const note = melody[i]; node[note] = node[note] || {}; node = node[note]; } node.isEnd = true; } search(melody) { let node = this.root; for (let i = 0; i < melody.length; i++) { const note = melody[i]; if (!node[note]) { return false; } node = node[note]; } return !!node.isEnd; }}const melodyTrie = new MelodyTrie();melodyTrie.insert(['C4', 'D4', 'E4']);melodyTrie.insert(['E4', 'F4', 'G4', 'A4']);melodyTrie.insert(['G4', 'F4', 'E4', 'D4']);melodyTrie.insert(['C4', 'C4', 'C4', 'C4']);console.log(melodyTrie.search(['C4', 'D4', 'E4'])); // trueconsole.log(melodyTrie.search(['C4', 'D4', 'E4', 'F4'])); // falseReference","url":"/blog/software/dsa/tries"},{"title":"(dsa) Dynamic-programming","content":"(dsa) Dynamic-programmingPurposeDynamic programming offers an efficient solution to large-scale optimization problems by breaking them into smaller sub-problems and avoiding repetitive computations, making it applicable across various disciplines including computer science, mathematics, engineering, economics, and operations research.ConceptAll dynamic programmings involve smartly finding relationship between bigger dataset and smaller dataset and try to formulate it.StepsFor example, given an integer array, [1, -2, 3, 4, -1, 2, 1, -5, 4], find the largest sum from a continuous sub-array.Try to find relationship between subset and setIt's all about pretending. I pretend I already have the solution of an subset, denoted as F(array[0..i-1]). Then the element of array[i] comes in. What's next? The problem immediately becomes Max(F(array[0..i-1]), array[i], F(array[0..i-1]) + array[i]). Let's only consider array[i] is positive. Then the problem becomes Max(array[i], F(array[0..i-1]) + array[i]).Define the base caseF(array[0]) = array[0]Implement the algorithmfunction maxSubArraySum(arr) { let maxSum = arr[0] for (let i = 1; i < arr.length; i++) { nextResult = Math.max(arr[i], dp[i - 1] + arr[i]) maxSum = Math.max(maxSum, nextResult); } return maxSum;}// Example usage:const array = [1, -2, 3, 4, -1, 2, 1, -5, 4];const result = maxSubArraySum(array);Analyze the time and space complexitySince it will only loop through all element once, the time complexity is O(n)Recursive vs. Iterative SolutionsAll recursive algorithms can be implemented iteratively. If the recursive solution takes too much memory, we can consider solve it iteratively.For example, we can calculate factorial with recursive and iterative method as follow:function factorialRecursive(n) { if(n == 1) { return 0 } else { return n * factorialRecursive(n - 1) }}function factorialIterative(n) { result = 1 for (let i = 1; i <= n; i ++) { result = result * i } return result}fibonacciConceptf(n) = f(n - 1) + f(n - 2)Recursivefunction fibonacci(n) { const memo = {}; function fibonacciHelper(n) { if (n <= 1) { return n; } else if (n in memo) { return memo[n]; } else { memo[n] = fibonacciHelper(n-1) + fibonacciHelper(n-2); return memo[n]; } } return fibonacciHelper(n);}console.log(fibonacci(10)); // Output: 55Time complexity: O(n) because with memo, I only need to know f(n), ... f(1)Triple StepProblem: A child is running up a staircase with n steps and can hop either 1 step, 2 steps, or 3 steps at a time, implement a method to count how many possible ways the child can run up the stairs.Concept (important dynamic programming concept): When the child hops on 5, we can guess this child hop 1, hop 2, or hop 3hop 1 => must hop to 4 before => the ways(4)hop 2 => must hop to 3 before => the ways(3)hop 3 => must hop to 2 before => the ways(2)As a result, we can conclude that ways(n) = ways(n-1) + ways(n-2) + ways(n-3)Solution:function childHop(n) { if (n == 1) { // [1] return 1 } else if (n == 2) { // [1, 1], [2] return 2 } else if (n == 3) { // [1, 1, 1], [2, 1], [1, 2], [3] return 4 } else { return childHop(n - 3) + childHop(n-2) + childHop(n-1) }}// childHop(5) = 13TestchildHop = require('./triple_step.js')describe('Triple Step', () => { test('when the stair has 5 steps', () => { expect(childHop(5)).toEqual(13) })})Robot in a GridQuestion: Imagine a robot sitting on the upper left corner of grid with r rows and c columns. The robot can only move in two directions, right and down, but certain cells are \"off limits\" such that the robot cannot step on them. Design an algorithm to find a path for the robot from the top left to the bottom right.ExampleInputr = 3 (number of rows)c = 4 (number of columns)Off-limit cells: [[1, 1], [2, 2], [2, 3]]Output: array of (x, y)Codeconst offLimitCells = [ { row: 1, col: 1 }, { row: 2, col: 2 }, { row: 2, col: 3 },];function path(x, y, offLimitCells, currentResult = []) { currentResult.push([x, y]) const inOffLimitCells = (target) => { if(offLimitCells.find((cell) => cell.row === target.row && cell.col === target.y)) { return true } else { return false } } if(x === 1 && y === 1) { return currentResult } let lastPoint if(x === 1 && !inOffLimitCells({ row: 1, col: y - 1 })) { lastPoint = { row: 1, col: y - 1 } } else if(y === 1 && !inOffLimitCells({ row: x - 1, col: 1 })) { lastPoint = { row: x - 1, col: 1 } } else if(!inOffLimitCells({ row: x - 1, col: y })) { lastPoint = { row: x - 1, col: y } } else if(!inOffLimitCells({ row: x, col: y - 1 })) { lastPoint = { row: x, col: y - 1 } } else { return 'no routes' } return path(lastPoint.row, lastPoint.col, offLimitCells, currentResult)}const result = path(3, 4, offLimitCells)Longest Common Subsequence (LCS)Please use the concept of dynamic programming to solve it.Exampless1 = \"ABCD\", s2 = \"ACDA\". The LCS is \"ACD\" with a length of 3.s1 = \"AGGTAB\", s2 = \"GXTXAYB\". The LCS is \"GTAB\" with a length of 4.s1 = \"abcdef\", s2 = \"xyz\". The LCS is an empty string \"\" with a length of 0.ConceptBuild a 2D table, row is s1 and column is s2 and if value matches, mark the cell value as 1, otherwise 0.ABCDA1000C0010D0001A1000Take a look at the table aboverow \"AC\" with col \"A\" => 1 and row \"ACD\" with col \"A\" => 1, which means it is impossible to increase LCS by increasing the letters of only s1 or s2 and also, DP[C][A] = 1; DP[D][A] = 1, ...etc.row \"ACDA\" with col \"A\" => 1 although there are two matches. It is impossible to increase LCS by only increase letters on one dimension because you must increase slots.DP[i][j] = DP[i-1][j-1] + 1 if row[i] = col[j]DP[i][j] = DP[i-1][j] or DP[i][j-1] if row[i] != col[j]CodeLet's try to write the codeTry iterativefunction longComSub(s1, s2) { result = [] for (i = 0; i < s1.length; i++) { // iteration result.push([]) // s1 will be row for (j = 0; j < s2.length; i++) { if (i === 0 && j === 0) { result[i][j] = (s1[i] === s2[j]) ? 1 : 0 } else if (i === 0) { result[i][j] = result[i][j - 1] } else if (j === 0) { result[i][j] = result[i - 1][j] } else if (s1[i] === s2[j]) { result[i][j] = result[i - 1][j - 1] } else { result[i][j] = Math.max(result[i - 1][j], result [i][j - 1]) // dynamic programming here } } }}Time complexity: O(m x n)TODOMagicIndexPower SetRecursive MultiplyTowers of HanoiPermutations without DupsPermutations with DupsParensPaint FillCoinsEight QueensStack of BoxesBoolean EvaluationExample(Real world) resource allocationProblem: Allocates scarce resources in the most efficient way possible to maximize the overall benefit or profit. The problem can be represented as a table where the rows represent the projects and the columns represent the available budget. The table is filled out in a bottom-up manner, where each cell represents the maximum profit that can be obtained for a given budget and a subset of projects. Resource allocation problems can arise in many different fields, such as in supply chain management, healthcare, and environmental management. By using dynamic programming to optimize resource allocation, businesses and organizations can make more informed decisions and achieve better outcomes.Example: Consider a company that has a limited budget and needs to allocate its resources (e.g., money, manpower, equipment) across different projects to maximize profits.Solution: Use dynamic programming solve this problem by breaking it down into smaller sub-problems and optimizing each subproblem independently. By computing the values in the table for all possible combinations of projects and budgets, the optimal solution can be found by selecting the combination of projects with the highest profit that also fits within the budget constraints.Code: Suppose we have a list of n tasks, each with an associated profit and time required. We also have a limited amount of time available to complete tasks. Our goal is to choose a subset of tasks to complete in the allotted time that maximizes the total profit. We can use dynamic programming to solve this problem by building a table where the rows represent the tasks and the columns represent the available time. We fill out the table in a bottom-up manner, computing the maximum profit that can be obtained for each subset of tasks and time.We want to find the most profitable tasks in a give time as followconst time = 5; // it can be changedconst tasks = [ { name: 'Task A', profit: 2, time: 1 }, { name: 'Task B', profit: 3, time: 2 }, { name: 'Task C', profit: 4, time: 3 }, { name: 'Task D', profit: 5, time: 4 },];The algorithm will construct table:[ [ 0, 0, 0, 0, 0, 0 ], [ 0, 2, 2, 2, 2, 2 ], [ 0, 2, 3, 5, 5, 5 ], [ 0, 2, 3, 5, 6, 7 ], [ 0, 2, 3, 5, 6, 7 ],]where row is accumulated profit of projects on given time (columns)And use dynamic programming:It will start from table[4][5], which has value of 7, the maximum profit the time limit can obtainThen extracts the solution by backtracking from the last cell of the tableAvoiding the repetition of sub-problems, recomputing the maximum profit that can be obtained for the same accumulated projects and time limit, which occurs multiple times if a recursive or a brute-force approach were usedTime complexity = O(n * time)function allocateResources(tasks, time) { const n = tasks.length; const table = Array.from({ length: n + 1 }, () => Array(time + 1).fill(0)); // construct desired structure // Rows are the accumulated projects and column are the limit of time for (let i = 1; i <= n; i++) { const { profit, time: taskTime } = tasks[i - 1]; for (let j = 1; j <= time; j++) { if (taskTime > j) { table[i][j] = table[i - 1][j]; } else { table[i][j] = Math.max(table[i - 1][j], profit + table[i - 1][j - taskTime]); } } } const solution = []; let i = n, j = time; while (i > 0 && j > 0) { if (table[i][j] === table[i - 1][j]) { i--; } else { const { profit, time: taskTime } = tasks[i - 1]; solution.unshift(tasks[i - 1]); i--; j -= taskTime; } } return { maxProfit: table[n][time], solution };}const time = 5;const tasks = [ { name: 'Task A', profit: 2, time: 1 }, { name: 'Task B', profit: 3, time: 2 }, { name: 'Task C', profit: 4, time: 3 }, { name: 'Task D', profit: 5, time: 4 },];const { maxProfit, solution } = allocateResources(tasks, time);console.log(`Max profit: ${maxProfit}`);console.log(`Solution: ${solution.map(task => task.name).join(', ')}`);Reference0/1 Knapsack Problem Dynamic ProgrammingKnapsack Problem","url":"/blog/software/dsa/dynamic-programming"},{"title":"","content":"","url":"/blog/software/dsa/sorting/main"},{"title":"(ood) Oop","content":"(ood) OopPurposeOOP provides a flexible and powerful way to organize and structure software applications.ConceptUse objects to represent and manipulate data. Objects are instances of classes that encapsulate data and methods (functions) that operate on that data.ClassWe use class to create objects and the class will define the attributes and methods these objects have. For example, a User class in any SaaS product would be as follow:class User { constructor(name) { // attributes this.name = name; } // methods sayHello() { console.log(\"Hello, my name is \" + this.name); }}Coupling and CohesionCoupling evaluates the interconnection level among software modules; decreasing it improves system maintainability, much like ensuring the independence of a position in a company, allowing for effortless replacement or suspension without complex dependencies.mathA math evaluation can help us rank the severity.where = number of output data parameters = number of input data parameters = number of output control parameters = number of input control parameters = number of global variables used as data = number of global variables used as control = number of modules called (fan-out) = number of modules calling the module under consideration (fan-in)data vs controlData parameters are values that represent input data that is used by the function or method to perform some computation or operation. For example, if a function calculates the area of a rectangle, the length and width of the rectangle would be passed as data parameters.Control parameters are values that represent instructions or options that modify the behavior of the function or method. They do not represent input data but rather control the flow of the function or method. For example, a function that sorts an array of numbers might have a control parameter that determines whether the sort should be ascending or descending.Decrease CouplingUse Interfaces: Reduces the dependencies between classes by defining a set of methods that a class must implementEncapsulate data: Hides the internal details of a class from other classes, preventing other classes from depending on the implementation details of a classDependency Injection: Injects dependencies into a class instead of creating them inside the class. By injecting dependencies, you can reduce the coupling between classes, making them easier to test and updateAvoid Global State: Global state refers to data that is accessible by multiple classes in a system. Global state can create strong dependencies between classes, making it harder to change one class without affecting others.Use Design Patterns: Design patterns are proven solutions to common programming problems. By using design patterns, you can reduce coupling and improve the maintainability of your code.InterfacesIf we design system with abstraction, encapsulation, minimizing number of variables,Implements abstraction and encapsulation thoroughly, making we only see the appearance of this function and use it easily; for example, we know the light can be on by switching the button but we do not know the logics behind it.Reduce the number of global variables used as data or control, as well as the number of input or output parameters, by providing a common interface that can be used by multiple clients.Reduce the number of modules called (fan-out) by promoting modular design and encouraging the use of common interfaces between modules. For example, built APIs and call the end points rather import the same modules many times.AbstractionSimplify complex systems by representing only the essential features, and interfaces, which define the contract between objects and the outside world.Abstraction shows only essential attributes; for example, in this world, there are lots of animals such as human, pig, ...etc and there are some identical characteristics, then we can first define a class, Animal and then subdivide it with inheritance rather than writing both classes having the same characteristics.class Animal { constructor () { } eat () { }}class Human extends Animal { speak () { }}class Pig extends Animal {}rather thanclass Human { constructor() { } eat() { } speak() { }}class Pig { constructor() { } eat() { }}EncapsulationEncapsulation involves concealing an object's inner workings while presenting clear interfaces, enhancing data integrity, modularity, and code reusability. For example, the private methods are example of encapsulation in ruby; you cannot use the methods outside the class, showing only the meaningful methods for outsiders.In javascript, we use '#'Encapsulate functionclass Example { #privateFunction() { console.log(\"This is a private function.\"); } publicFunction() { console.log(\"Calling public function.\"); this.#privateFunction(); }}const instance = new Example(); instance.publicFunction(); // Output: Calling public function. // This is a private function.instance.#privateFunction(); // This will result in an errorEncapsulate attributeclass Person { #name; constructor(name) { this.#name = name; } getName() { return this.#name; }}const person1 = new Person(\"Alice\");console.log(person1.getName()); // Output: \"Alice\"console.log(person1.#name); // This will result in an errorInheritanceOne class (the child or subclass) can inherit the properties and methods of another class (the parent or superclass). This allows for code reuse and promotes modularity and extensibility.For example, I want to create Animals: Dog, Cat, Bird.class Animal { move() { console.log(`${this.constructor.name} is moving`); }}class Dog extends Animal {}class Cat extends Animal {}class Bird extends Animal {}const dog = new Dog();const cat = new Cat();const bird = new Bird();dog.move(); // Output: Dog is movingcat.move(); // Output: Cat is movingbird.move(); // Output: Bird is movingPolymorphismPolymorphism refers to the ability of objects of different classes to be treated as if they are of the same class. This allows for more flexible and dynamic programming, as objects can be used interchangeably without the need for complex type checking and casting.For example, I want to create Animals: Dog, Cat, Bird I can write a polymorphic class as follow:class Animal { static DOG = 0; static CAT = 1; static BIRD = 2; constructor(type) { this.type = type; } speak() { switch (this.type) { case Animal.DOG: console.log('bark'); break; case Animal.CAT: console.log('meow'); break; case Animal.BIRD: console.log('tweet'); break; default: console.log('Unknown animal'); } }}const animals = [ new Animal(Animal.DOG), new Animal(Animal.CAT), new Animal(Animal.BIRD)];animals.forEach(animal => { animal.speak();});polymorphism vs inheritanceIt depends on the business logic to determine which one to be used. Think about your database. If we use inheritance, then there will be a new model produced which you can create a table associate with it and you will not need runtime to calculate the logics, of which you cost more space but save more time and vice versa.For example, the same Dog class. If you are running a zoo, you will not need a table for Dog and you just need a polymorphism table, Animal, to list all the animals with type in that table. But if you are running, a store professionally takes good care about dogs, then you need a Dog model inherited from Animal.ReferenceThe Basics of OOP RubyRuby Tutorial: Abstract ClassesCoupling (computer programming)What is the definition of \"interface\" in object oriented programming4.7: Introduction to Polymorphism - The Nature of CodeDesign Patterns in Plain English | Mosh Hamedanimjx-container[jax=\"SVG\"] { direction: ltr;}mjx-container[jax=\"SVG\"] > svg { overflow: visible; min-height: 1px; min-width: 1px;}mjx-container[jax=\"SVG\"] > svg a { fill: blue; stroke: blue;}mjx-container[jax=\"SVG\"][display=\"true\"] { display: block; text-align: center; margin: 1em 0;}mjx-container[jax=\"SVG\"][display=\"true\"][width=\"full\"] { display: flex;}mjx-container[jax=\"SVG\"][justify=\"left\"] { text-align: left;}mjx-container[jax=\"SVG\"][justify=\"right\"] { text-align: right;}g[data-mml-node=\"merror\"] > g { fill: red; stroke: red;}g[data-mml-node=\"merror\"] > rect[data-background] { fill: yellow; stroke: none;}g[data-mml-node=\"mtable\"] > line[data-line], svg[data-table] > g > line[data-line] { stroke-width: 70px; fill: none;}g[data-mml-node=\"mtable\"] > rect[data-frame], svg[data-table] > g > rect[data-frame] { stroke-width: 70px; fill: none;}g[data-mml-node=\"mtable\"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed { stroke-dasharray: 140;}g[data-mml-node=\"mtable\"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted { stroke-linecap: round; stroke-dasharray: 0,140;}g[data-mml-node=\"mtable\"] > g > svg { overflow: visible;}[jax=\"SVG\"] mjx-tool { display: inline-block; position: relative; width: 0; height: 0;}[jax=\"SVG\"] mjx-tool > mjx-tip { position: absolute; top: 0; left: 0;}mjx-tool > mjx-tip { display: inline-block; padding: .2em; border: 1px solid #888; font-size: 70%; background-color: #F8F8F8; color: black; box-shadow: 2px 2px 5px #AAAAAA;}g[data-mml-node=\"maction\"][data-toggle] { cursor: pointer;}mjx-status { display: block; position: fixed; left: 1em; bottom: 1em; min-width: 25%; padding: .2em .4em; border: 1px solid #888; font-size: 90%; background-color: #F8F8F8; color: black;}foreignObject[data-mjx-xml] { font-family: initial; line-height: normal; overflow: visible;}mjx-container[jax=\"SVG\"] path[data-c], mjx-container[jax=\"SVG\"] use[data-c] { stroke-width: 3;}","url":"/blog/software/ood/oop"},{"title":"(ood) Solid","content":"(ood) SolidPurposeBuilding Robust and Maintainable Software with the SOLID Principles.ConceptLet's say we have a class User, which can CRUD usersclass UserService { constructor() { // Initialize user data or database connection } createUser(userData) { // Logic to create a new user } updateUser(userId, newData) { // Logic to update user information } deleteUser(userId) { // Logic to delete a user } getUser(userId) { // Logic to retrieve user information } // Other user-related methods...}Single Responsibility Principle (SRP)A class should have only one reason to change, which means it should have only one responsibility. To achieve it, let's define four different class and use them in UserService. Then when we need to change a method, we actually change the class of the method, not UserService, ensuring only one reason to change.class UserRepository { constructor() { // Initialize user data or database connection } createUser(userData) { // Logic to create a new user in the database } updateUser(userId, newData) { // Logic to update user information in the database } deleteUser(userId) { // Logic to delete a user from the database } getUser(userId) { // Logic to retrieve user information from the database }}class UserCreator { constructor(userRepo) { this.userRepo = userRepo; } createUser(userData) { // Logic to create a new user this.userRepo.createUser(userData); }}class UserUpdater { constructor(userRepo) { this.userRepo = userRepo; } updateUser(userId, newData) { // Logic to update user information this.userRepo.updateUser(userId, newData); }}class UserDeleter { constructor(userRepo) { this.userRepo = userRepo; } deleteUser(userId) { // Logic to delete a user this.userRepo.deleteUser(userId); }}class UserRetriever { constructor(userRepo) { this.userRepo = userRepo; } getUser(userId) { // Logic to retrieve user information return this.userRepo.getUser(userId); }}and use them withconst userRepository = new UserRepository();const userCreator = new UserCreator(userRepository);const newUser = { /* user data */ };userCreator.createUser(newUser);We pass userRepository into UserCreator.Open-Closed Principle (OCP)The Open-Closed Principle promotes the idea that software entities (such as classes, modules, functions, etc.) should be open for extension but closed for modification. Based on above example, let's say we need special callback when create a user, then we can extend it without modifying the old logic byclass SpecialUserCreator extends UserCreator { createUser(userData) { console.log('create a new user callback') this.userRepo.createUser(userData); }}Liskov Substitution Principle (LSP)Child classes behave the same way as parent class in other function calling them. Based on above example,function createUserNotification(createTool, userData) { return createTool.createUser(userData)}const specialUserCreate = new SpecialUserCreator()const userCreate = new UserCreator()createUserNotification(specialUserCreate, userData)createUserNotification(userCreate, userData)If we do not use inheritance, then Dog may not have the makeSound method, causing animalMakesSound raises error.Interface Segregation Principle (ISP)Clients should not be forced to depend on interfaces they do not use; for example, we want to create a user, then we should only need to create this user with the required userData, not any other interfaces or methods. Actually, the example above has already achieve ISP.Dependency Inversion Principle (DIP)The Dependency Inversion Principle emphasizes that high-level modules should not depend on low-level modules, but both should depend on abstractions. In the above example, we actually already achieve DIP because actually create method in userCreator(higher-level) is separated from userRepository (lower-level).const userRepository = new UserRepository();const userCreator = new UserCreator(userRepository);const newUser = { /* user data */ };userCreator.createUser(newUser);UserRepository is lower level because we pass it into UserCreator.ReferenceGPT","url":"/blog/software/ood/solid"},{"title":"(design-pattern) Main","content":"(design-pattern) MainPurposeDesign patterns provide standardized solutions to common software design problems, enhancing code reusability and extensibility in object-oriented systems.ConceptMain 23 design patternsCreationalDifferent ways to create objectsExampleFactory method: Factory method provides a way to delegate the creation of objects to subclasses. It's useful when you want to create objects without specifying the exact class of object that will be created.Builder: Builder separates the construction of a complex object from its representation, so that the same construction process can create different representations. It's useful when you want to create complex objects with many optional parameters.Prototype: Prototype involves creating new objects by cloning existing objects. It's useful when creating objects is expensive, and you want to reuse existing objects.Singleton: Singleton ensures that only one instance of a class can be created, and provides a global point of access to that instance. It's useful when you want to limit the number of instances of a class, or when you need to coordinate actions across the system.Abstract Factory: This pattern provides an interface for creating families of related objects, without specifying the concrete classes of those objects. It's useful when you want to create objects that share a common interface, but have different implementations.StructuralStructural design patterns deal with object composition and provide ways to organize objects to form larger structuresExampleComposite: This pattern allows you to create hierarchical structures of objects by composing objects into tree structures. It's useful when you want to represent part-whole hierarchies.Decorator: This pattern allows you to add behavior to objects dynamically by wrapping them in an object of a decorator class. It's useful when you want to add functionality to an object without changing its interface.Adapter: This pattern allows you to adapt an object to another interface, without changing the underlying object. It's useful when you want to reuse existing code with a different interface.Proxy: This pattern provides a surrogate or placeholder for another object to control access to it. It's useful when you want to add security, logging, or caching to an object.Bridge: This pattern separates an object's interface from its implementation, so that the two can vary independently. It's useful when you want to decouple an abstraction from its implementation, allowing both to evolve independently.Facade: This pattern provides a simplified interface to a complex subsystem of objects. It's useful when you want to provide a simple interface to a complex system.Flyweight: This pattern allows you to share objects to reduce memory usage, by sharing common parts of state between objects. It's useful when you want to create many objects with similar state.BehavioralBehavioral design patterns deal with communication between objects and how objects interact with each otherExampleObserver: This pattern allows you to define a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically. It's useful when you want to keep multiple objects in sync with each other.Template Method: This pattern defines the skeleton of an algorithm in a base class, allowing subclasses to provide concrete implementations of certain steps. It's useful when you want to define the basic structure of an algorithm, while allowing certain steps to be customized.Strategy: This pattern allows you to define a family of interchangeable algorithms, encapsulate each one, and make them interchangeable at runtime. It's useful when you want to choose an algorithm dynamically, based on runtime conditions.Interpreter: This pattern provides a way to define the grammar of a language, and to interpret sentences in that language.Visitor: Allows you to add new behaviors or operations to a set of objects without modifying their structure. It achieves this by defining separate visitor objects that can traverse and operate on the elements of a complex object structure.Command: Encapsulates a request as an object, allowing for parameterization of clients with different requests, queuing of requests, and logging of the commands, thus decoupling the sender and receiver of the command.Iterator:Mediator:Memento:State:Chain of Responsibility:ReferenceSoftware design patternDesign Patterns in Plain English Mosh Hamedani","url":"/blog/software/design-pattern/main"},{"title":"(system-design) Scalability","content":"(system-design) ScalabilityPurposeLearning about horizontal and vertical scalability is essential to efficiently handle increasing workloads, maintain system performance and availability, and achieve cost efficiency in computer systems and software engineering.ConceptHorizontal scalability (scale-out)Adding more machines or nodes in a distributed manner, allowing for improved workload distribution, increased throughput, and enhanced fault tolerance.Example: Add more web servers to app's cluster, allowing for better load distribution and improved fault tolerance.// File: server.jsconst http = require('http');const cluster = require('cluster');const os = require('os');const numCPUs = os.cpus().length;if (cluster.isMaster) { // Create a worker process for each CPU core for (let i = 0; i < numCPUs; i++) { cluster.fork(); } cluster.on('exit', (worker, code, signal) => { console.log(`Worker ${worker.process.pid} died`); // Fork a new worker if a worker process dies cluster.fork(); });} else { // Create and start your Node.js server const server = http.createServer((req, res) => { res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello, World!'); }); server.listen(3000, () => { console.log(`Server running on process ${process.pid}`); });}When running the server, the master process will execute the code before the else block and create multiple workers through cluster.fork() and the multiple workers with execute the code within the else block, creating multiple instances of server to handle incoming requests. Then we have multiple nodes.Vertical Scalability (scale-up)Adding more resources, such as CPU, memory, or storage, to a single machine or node, enabling it to handle larger workloads and support higher performance requirements.Example: Upgrade the server's resources, such as adding more CPU cores, increasing memory capacity, or improving storage performance.// File: server.jsconst express = require('express');const app = express();// Set up your routes and middlewareapp.get('/', (req, res) => { res.send('Hello, World!');});// Start the serverconst server = app.listen(3000, () => { console.log('Server running on port 3000');});// Example of vertical scaling by upgrading resourcesfunction upgradeServer() { // Upgrade CPU, memory, or storage resources as needed // ... // Close the existing server and start a new server with upgraded resources server.close(() => { const upgradedServer = app.listen(3000, () => { console.log('Upgraded server running on port 3000'); }); server = upgradedServer; });}// Call upgradeServer() when resource upgrade is requiredWe can write logic to use upgradeServer() optionally. When calling upgradeServer, it will close old server and call the upgraded one.Horizontal vs VerticalPurposeFind the best solution with least cost to increase the capacity of a systemConceptThe choice depends on various factorsNature of the workloadPerformance requirementsCost considerationsArchitecture of the systemExampleCost: Horizontal scaling < Vertical scalingHorizontal scaling involves adding commodity hardware, which can be cost-effective.Vertical scaling requires investing in high-end hardware, which can be more expensive.Scalability requirements: predictable or notIf workload is predictable, vertical scaling can be sufficient.If workload is not predictable, horizontal scaling may provide better scalability with the ability to add more machines as needed.System architectureIf the system is already distributed and designed for horizontal scalability, it may be easier to continue scaling horizontally.If the system is designed around a single powerful server, vertical scaling may be the preferred option.ReferenceChatGPT","url":"/blog/software/system-design/scalability"},{"title":"(os) Process-management","content":"(os) Process-managementPurposeUnderstanding operating systems and properly managing processes allows for efficient code, improved system stability, concurrent system development, and effective issue identification and debugging.Concept#mark27915{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark27915 .error-icon{fill:#552222;}#mark27915 .error-text{fill:#552222;stroke:#552222;}#mark27915 .edge-thickness-normal{stroke-width:2px;}#mark27915 .edge-thickness-thick{stroke-width:3.5px;}#mark27915 .edge-pattern-solid{stroke-dasharray:0;}#mark27915 .edge-pattern-dashed{stroke-dasharray:3;}#mark27915 .edge-pattern-dotted{stroke-dasharray:2;}#mark27915 .marker{fill:#333333;stroke:#333333;}#mark27915 .marker.cross{stroke:#333333;}#mark27915 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark27915 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark27915 .cluster-label text{fill:#333;}#mark27915 .cluster-label span,#mark27915 p{color:#333;}#mark27915 .label text,#mark27915 span,#mark27915 p{fill:#333;color:#333;}#mark27915 .node rect,#mark27915 .node circle,#mark27915 .node ellipse,#mark27915 .node polygon,#mark27915 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark27915 .flowchart-label text{text-anchor:middle;}#mark27915 .node .label{text-align:center;}#mark27915 .node.clickable{cursor:pointer;}#mark27915 .arrowheadPath{fill:#333333;}#mark27915 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark27915 .flowchart-link{stroke:#333333;fill:none;}#mark27915 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark27915 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark27915 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark27915 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark27915 .cluster text{fill:#333;}#mark27915 .cluster span,#mark27915 p{color:#333;}#mark27915 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark27915 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark27915 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}compiledloadeddecomposedecompose...decomposedecomposedecompose...decomposeprogrambinary formmemoryprocess 1process 2...other processesthread 1thread 2...other threadsFlow of processCreationGoal: To solve the program we required computer doSteps:Allocating resources: OS sets up address space, allocates memory, and creates a page table.Initializing data structures: Process control block (PCB) is initialized with process details.Setting up the environment: OS prepares initial program counter, stack pointer, and registers.SchedulingGoal: Optimize CPU utilization, minimize response time, ensure fairness in resource allocation.Steps:Determines process execution order on the CPU.Scheduler selects processes from the ready queue based on a scheduling algorithm.SynchronizationGoal: Avoids race conditions, deadlocks, and data inconsistencies on shared resource access and task cooperation.Steps: Uses synchronization mechanisms (locks, semaphores, mutexes) to prevent conflicts.TerminationGoal: Release resources (memory, files, system resources) when a process finishes execution or is forcibly terminated.Concept: Process control block is updated and associated data structures are de-allocated.Process Control Block (PCB)The PCB serves a pivotal role in managing tasks like task creation, scheduling, and termination within an operating system, while its data structure holds essential process information such as state, priority, and registers. By preserving process state through context switching, the PCB facilitates multitasking and concurrent execution, underlining its significance in modern OS process management. The PCB is initiated upon process creation, containing and updating vital information like process ID, memory allocation, and CPU usage as the process runs, enabling effective process tracking and CPU scheduling.#mark19028{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark19028 .error-icon{fill:#552222;}#mark19028 .error-text{fill:#552222;stroke:#552222;}#mark19028 .edge-thickness-normal{stroke-width:2px;}#mark19028 .edge-thickness-thick{stroke-width:3.5px;}#mark19028 .edge-pattern-solid{stroke-dasharray:0;}#mark19028 .edge-pattern-dashed{stroke-dasharray:3;}#mark19028 .edge-pattern-dotted{stroke-dasharray:2;}#mark19028 .marker{fill:#333333;stroke:#333333;}#mark19028 .marker.cross{stroke:#333333;}#mark19028 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark19028 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark19028 .cluster-label text{fill:#333;}#mark19028 .cluster-label span,#mark19028 p{color:#333;}#mark19028 .label text,#mark19028 span,#mark19028 p{fill:#333;color:#333;}#mark19028 .node rect,#mark19028 .node circle,#mark19028 .node ellipse,#mark19028 .node polygon,#mark19028 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark19028 .flowchart-label text{text-anchor:middle;}#mark19028 .node .label{text-align:center;}#mark19028 .node.clickable{cursor:pointer;}#mark19028 .arrowheadPath{fill:#333333;}#mark19028 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark19028 .flowchart-link{stroke:#333333;fill:none;}#mark19028 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark19028 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark19028 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark19028 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark19028 .cluster text{fill:#333;}#mark19028 .cluster span,#mark19028 p{color:#333;}#mark19028 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark19028 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark19028 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}processingadmittedscheduler dispatchinterruptI/O or event waitI/O or event completionexitrunningreadywaitingnewterminatedProcess vs ThreadThreads share the same resources of the process they belongs to, such as memory and files in the same process; processes take their own part of memory and cannot share memory with other process.Communication between threads is faster than processes.Threads are scheduled by the operating system, but they are not self-contained like processes.IssuesHere I put more efforts on deadlock, synchronization, and raceDeadlockA deadlock occurs when two or more processes are blocked waiting for each other to release a resource. Deadlocks can lead to a system freeze, where no progress is made, and the processes become unresponsiveSolutions (order with frequency)Mutual ExclusionDescription: Two resources, A and B, and two processes, P1 and P2, that need access to both resources in order to complete their tasks. However, if both processes acquire one resource and then try to acquire the other, they may end up deadlocked, where neither process can proceed because they are both waiting for the other to release the resource it is holding.Solution: Give each resource a lock. That is, processes P1 or P2 must gain the lock of each resource, then they can start to process, which means P1 and P2 are mutual exclusiveCode example:// Create a Mutex objectconst mutex = new Mutex();// Acquire the lockmutex.acquire().then(function() { // Critical section // Code here will be executed by only one thread at a time // Release the lock mutex.release();});// Mutex object is created and then the acquire() method is called to acquire the lock. If the lock is currently held by another thread, the acquire() method will block until it is released. Once the lock is acquired, the critical section of code is executed. Once the critical section is complete, the release() method is called to release the lock and allow other threads to acquire it.Deadlock detection and recovery algorithms: These are widely used in many operating systems and databases to detect and recover from deadlocks.Resource allocation policies: These policies are commonly used to allocate resources in a way that minimizes the risk of deadlocks. For example, some systems use priority-based scheduling to give higher priority to processes that are less likely to cause deadlocks.Message passing: This technique is often used in distributed systems to ensure that processes can communicate with each other without the risk of deadlocks.Lock-free programming: This technique is gaining popularity in highly concurrent systems because it avoids the need for locks and can improve performance.Transactional memory: This is a relatively new technique that is gaining popularity in highly concurrent systems because it allows for fine-grained locking and can improve performance.Hold and Wait: This strategy can be effective in some situations, but it can also be prone to deadlocks if not used carefully.No Preemption: This strategy can prevent deadlocks, but it can also lead to resource starvation in certain situations.Circular Wait: This strategy can be effective, but it requires careful resource allocation and ordering to prevent deadlocks.Synchronization for ConsistencyProcesses may need to synchronize their activities to ensure correct and consistent behavior. Synchronization problems can arise when processes access shared resources, communicate with each other, or perform parallel computations.SolutionLocks: lock all the other process when this process is processing.Semaphores: A way to mark a resource and make sure only pre-defined number of processes can use this resource.class Semaphore { constructor(initialCount) { this.count = initialCount; this.queue = []; } async acquire() { if (this.count > 0) { this.count--; } else { await new Promise(resolve => this.queue.push(resolve)); } } release() { this.count++; if (this.queue.length > 0) { const resolve = this.queue.shift(); resolve(); } }}const semaphore = new Semaphore(2); // Allow one process at a timeasync function sharedResourceAccess(id) { console.log(`Process ${id} is waiting for access.`); await semaphore.acquire(); console.log(`Process ${id} has acquired access to the shared resource.`); // Simulating some work being done with the shared resource await new Promise(resolve => setTimeout(resolve, 2000)); console.log(`Process ${id} is releasing the shared resource.`); semaphore.release(); // This step will increase the count and }// Create multiple processes trying to access the shared resourceasync function runProcesses() { for (let i = 1; i <= 5; i++) { sharedResourceAccess(i); }}runProcesses();When I call runProcesses, because of async, it called 5 sharedResourceAccess at the same time without waiting each other. In sharedResourceAccess, there is await statement of semaphore.acquire(), meaning it will wait until acquire finish.acquire will check the number of processes we pre-defined to use the resource and if this resource is not available, it will wait resolve to be pushed into the queue.After the work done in sharedResourceAccess, it will do release() and the resolve() will be called, making Promise to receive the resolve and then the acquire passed.Then now we do not need to wait any acquire and the count is > 0, so we can do other tasks in other sharedResourceAccess.BarriersMutex vs SemaphoreThey have different purpose. Mutexes are used to provide exclusive access to a shared resource to only one thread at a time, ensuring that multiple threads do not concurrently modify the same resource. Semaphores can be used to control access to a set of resources, allowing a certain number of threads to access them simultaneously while restricting others.Race ConditionsDescription: A race condition occurs when two or more processes access a shared resource concurrently, and the outcome depends on the order of executionSolution: To prevent race conditions, you can use synchronization techniques like locks, semaphores, and barriers. You can also use atomic operations and message passing to ensure that shared resources are accessed safely and consistently.Resource AllocationDescription: Resource starvation or overloading caused by failing to manage resource efficiently for different processes, which require different amounts of CPU, memory, disk space, network bandwidth, and other resources.Solution: To manage resources effectively, you can use tools like task queues, load balancers, and resource allocation algorithms; for example, when a task is received, it is initially directed to available machines through load balancers. Subsequently, the task is enqueued on the designated machine using task queues, followed by the application of a resource allocation algorithm to efficiently assign the necessary resources for its execution on that machine.Task queues: Task queues are systems that manage and execute tasks asynchronously, enabling efficient handling of operations like calculations, network requests, or file processing. They use queues to organize tasks, allowing producers to add tasks and consumers to retrieve and process them, offering advantages like concurrency, scalability, and asynchronous processing.Load balancers: Load balancers are networking devices or software systems that distribute incoming network traffic, such as requests to a web server, across multiple servers or resources. This distribution optimizes resource utilization, enhances reliability, and ensures efficient handling of user requests, contributing to improved performance and availability of services.Resource allocation algorithm: Resource allocation algorithms are techniques used by operating systems and other systems to efficiently distribute and manage available resources, such as CPU time, memory, disk space, and network bandwidth, among competing processes or tasks. These algorithms help ensure that resources are utilized optimally to achieve desired performance, fairness, and responsiveness in a multi-tasking environment.Priority InversionDescription: Priority inversion is a situation where a low-priority process holds a resource that a high-priority process needs, leading to a delay in the high-priority process's execution. This problem is particularly prevalent in real-time systems.Solution: To prevent priority inversion, you can use techniques like priority inheritance, priority ceiling, and preemptive scheduling. These techniques ensure that high-priority processes get access to the resources they need without being delayed by low-priority processes.Fault ToleranceProcess management may need to handle faults and failures gracefully to maintain system availability and reliability. Fault tolerance mechanisms include process restarts, redundancy, and error detection and recovery.SecurityProcess management needs to enforce access control and protect against unauthorized access, malicious attacks, and other security threats.ReferenceProcess control blockOperating System: Process and Process ManagementProcess Management in OS: PCB in Operating SystemProcess Control Block","url":"/blog/software/os/process-management"},{"title":"(database) Mysql","content":"(database) MysqlPurposeLearning MySQL is valuable because it equips you with the essential skills to efficiently manage and manipulate relational databases, empowering you to handle data effectively in a wide range of applications and industries.ConceptInitInstall: brew install mysqlStart: brew services start mysqlOpen console: mysql -u root -p and then enter passwordDatabaseCreate: CREATE DATABASE desired_database_nameReadDatabases: SHOW DATABASES;Specific database: USE database_name;Updaterename databasefirst approach (details below): create a new database -> move tables to new database -> remove the old databasesecond approach (details below): export and import with mysqldumpDestroy: drop database <db_name>;TableCreate: CREATE TABLE desired_table_name ...Example:CREATE TABLE users(id INT(11) AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100), email VARCHAR(100), username VARCHAR(30), password VARCHAR(100), register_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP);Read: SHOW TABLES;Updaterename table: RENAME TABLE tb1 TO tb2;transfer table: CREATE TABLE destination_db.my_table SELECT * FROM source_db.my_table;Destroy: DROP TABLE \"TABLE_NAME\";RowCreate: INSERT INTO table_name(attributes...) VALUES(values...)ReadAll rows: SELECT * FROM table_name;Specific condition: SELECT * FROM table_name where xxxSpecific column: SELECT xxx FROM table_nameUpdateDestroy: DELETE FROM ‘table_name’ WHERE id = 1 LIMIT 1Data typeRefer to data type.SyntaxGROUP BY & HAVINGSELECT column1, column2, aggregate_function(column3)FROM table_nameGROUP BY column1, column2HAVING aggregate_function(column3) condition;The concept of GROUP BY is to group the rows according to the values of the columns. After we have the GROUP BY, we can then use aggregate_function to manipulate the data of these groups; for example, sum(column3) will return sum of the value of the column3 on each group with specific value of column1 and column2.ExampleMultiple Apartments#mark45289{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark45289 .error-icon{fill:#552222;}#mark45289 .error-text{fill:#552222;stroke:#552222;}#mark45289 .edge-thickness-normal{stroke-width:2px;}#mark45289 .edge-thickness-thick{stroke-width:3.5px;}#mark45289 .edge-pattern-solid{stroke-dasharray:0;}#mark45289 .edge-pattern-dashed{stroke-dasharray:3;}#mark45289 .edge-pattern-dotted{stroke-dasharray:2;}#mark45289 .marker{fill:#333333;stroke:#333333;}#mark45289 .marker.cross{stroke:#333333;}#mark45289 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark45289 .entityBox{fill:#ECECFF;stroke:#9370DB;}#mark45289 .attributeBoxOdd{fill:#ffffff;stroke:#9370DB;}#mark45289 .attributeBoxEven{fill:#f2f2f2;stroke:#9370DB;}#mark45289 .relationshipLabelBox{fill:hsl(80, 100%, 96.2745098039%);opacity:0.7;background-color:hsl(80, 100%, 96.2745098039%);}#mark45289 .relationshipLabelBox rect{opacity:0.5;}#mark45289 .relationshipLine{stroke:#333333;}#mark45289 .entityTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark45289 #MD_PARENT_START{fill:#f5f5f5!important;stroke:#333333!important;stroke-width:1;}#mark45289 #MD_PARENT_END{fill:#f5f5f5!important;stroke:#333333!important;stroke-width:1;}#mark45289 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}ApartmentsintaptIdvarchar(10)unitNumberintbuildingIdAptTenantsinttenantIdintaptIdTenantsinttenantIdvarchsr(100)tenantNamehas_many_tenants_throughhas_many_apartments_throughQuestion: Write a SQL query to get a list of tenants who are renting more than one apartment.Code:SELECT Tenants.tenantName FROM Tenants joins AptTenants on Tenants.tenantId = AptTenants.tenantId GROUP BY Tenants.tenantId HAVING COUNT(AptTenants.aptId) > 1insert csvCreate table with same column names of csv fileCREATE TABLE Nikkei_225 ( id INT NOT NULL AUTO_INCREMENT, Date DATE NOT NULL, Open DECIMAL(19, 4), High DECIMAL(19, 4), Low DECIMAL(19, 4), Close DECIMAL(19, 4), Adj_Close DECIMAL(19, 4), PRIMARY KEY (id));Load csv dataLOAD DATA INFILE '/private/tmp/C.csv' INTO TABLE Nikkei_225 FIELDS TERMINATED BY ',' ENCLOSED BY '\"' LINES TERMINATED BY '\\n' IGNORE 1 ROWS;FIELDS TERMINATED BY ',' means the method to separate each data in a row is by ,ENCLOSED BY '\"' means each data is warped by \"LINES TERMINATED BY '\\n' means the separating method between each line is \\n, the regular expression representing change lineIGNORE 1 ROWS means the process during import csv file will ignore the column names whose location is on first rowReference","url":"/blog/software/database/mysql"},{"title":"(design-pattern) Factory-method","content":"(design-pattern) Factory-methodPurposeFactory manufactures lots of products with some common characteristics. The factory method pattern demonstrates the way to create various classes with some common characteristics, meaning we do not need lots of class to create lots of objects with some common features.ConceptThe key concept lays on that factory determines which products to be produced on the product line, which means factory method design pattern determines which kind of object to be produced on compile time.For example, you are creating a game and there are various maps in the world. You can use the factory method pattern to create the monsters in the world with creation logic you want. If I want the maps all fill with various monster randomly, then the UML would be as follow:#mark56617{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark56617 .error-icon{fill:#552222;}#mark56617 .error-text{fill:#552222;stroke:#552222;}#mark56617 .edge-thickness-normal{stroke-width:2px;}#mark56617 .edge-thickness-thick{stroke-width:3.5px;}#mark56617 .edge-pattern-solid{stroke-dasharray:0;}#mark56617 .edge-pattern-dashed{stroke-dasharray:3;}#mark56617 .edge-pattern-dotted{stroke-dasharray:2;}#mark56617 .marker{fill:#333333;stroke:#333333;}#mark56617 .marker.cross{stroke:#333333;}#mark56617 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark56617 g.classGroup text{fill:#9370DB;fill:#131300;stroke:none;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:10px;}#mark56617 g.classGroup text .title{font-weight:bolder;}#mark56617 .nodeLabel,#mark56617 .edgeLabel{color:#131300;}#mark56617 .edgeLabel .label rect{fill:#ECECFF;}#mark56617 .label text{fill:#131300;}#mark56617 .edgeLabel .label span{background:#ECECFF;}#mark56617 .classTitle{font-weight:bolder;}#mark56617 .node rect,#mark56617 .node circle,#mark56617 .node ellipse,#mark56617 .node polygon,#mark56617 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark56617 .divider{stroke:#9370DB;stroke-width:1;}#mark56617 g.clickable{cursor:pointer;}#mark56617 g.classGroup rect{fill:#ECECFF;stroke:#9370DB;}#mark56617 g.classGroup line{stroke:#9370DB;stroke-width:1;}#mark56617 .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mark56617 .classLabel .label{fill:#9370DB;font-size:10px;}#mark56617 .relation{stroke:#333333;stroke-width:1;fill:none;}#mark56617 .dashed-line{stroke-dasharray:3;}#mark56617 .dotted-line{stroke-dasharray:1 2;}#mark56617 #compositionStart,#mark56617 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark56617 #compositionEnd,#mark56617 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark56617 #dependencyStart,#mark56617 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark56617 #dependencyStart,#mark56617 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark56617 #extensionStart,#mark56617 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark56617 #extensionEnd,#mark56617 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark56617 #aggregationStart,#mark56617 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark56617 #aggregationEnd,#mark56617 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark56617 #lollipopStart,#mark56617 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark56617 #lollipopEnd,#mark56617 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark56617 .edgeTerminals{font-size:11px;}#mark56617 .classTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark56617 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}is ais ais ais acreated_bycreated_byMonstercommon_attributescommon_methods()MonsterHardsome_hard_attributessome_hard_method()MonsterEasysome_easy_attributessome_easy_method()Creatorfactory_method()create()HardModeCreatorcreate_more_hard_monsters()EasyModeCreatorcreate_more_easy_monsters()Exampleclass Creator { factory_method() { throw new Error(`${this.constructor.name} has not implemented method '${this.factory_method.name}'`); } create() { const product = this.factory_method(); product.roar(); }}class HardModeCreator extends Creator { factory_method() { return new MonsterHard(); }}class EasyModeCreator extends Creator { factory_method() { return new MonsterEasy(); }}class Monster { roar() { throw new Error(`${this.constructor.name} has not implemented method '${this.roar.name}'`); }}class MonsterHard extends Monster { roar() { console.log('hard monster come!'); }}class MonsterEasy extends Monster { roar() { console.log('easy monster come!'); }}function create_monster(type) { let factory switch(factory) { case 'hard': factory = HardModeCreator() break; case 'easy': factory = EasyModeCreator() break } factory.create();}create_monster('hard');create_monster('easy');As you can see, all the monster creation use the method, create_monster and call different type of factory. And the Creator and Monster all inherited from interface that follows the SOLID.ReferenceFactory Method Pattern – Design Patterns (ep 4)Factory Method in Ruby","url":"/blog/software/design-pattern/factory-method"},{"title":"(design-pattern) Prototype","content":"(design-pattern) PrototypePurposeRun time saving (no need to reconstructure the file)Avoid objects created dependent on class (we do not need to modify class to create new objects, which may affect the objects created after the midification)Some private field must only connected to this object cannot be used in other objectConceptFor example, at first, there is only one supervisor and the host needs to print file with the title of that supervisor; however, right before the meeting, another supervisor requests to join the meeting, so we need another same file with different title. The host now may have these options:copy the file and change the title of the copyed file (V)change the title of the file and print it out -> increaseing the risk that the wrong title printed out in other filerewrite the whole file -> takes too much time and some informations from private third-party departments may not be available while rewritingsome confidential informations may need the customized styles to emphasize only used in this particular file for particular meetingsPrototype design pattern serves as the same concepts of the copy process (option 1); for creating new object by clone other object and do required modifications at run time.the concept of copyGiven the documents looks like{ :title => 'supervisor_1', :article => ['article_1', 'article_2'], :confidential => ['confidential_1', 'confidential_2']}While programming, we may just declare another variable and change the title as followx1 = { :title => 'supervisor_1', :article => ['article_1', 'article_2'], :confidential => ['confidential_1', 'confidential_2']}x2 = x1x2[:title] = 'supervisor_2'puts x1 # the title changedThe title changed because both x2 and x1 points to the same object. We need the concept of copy to help usshallow copy (only copy the first layer and the objects of second layer still points to the same objects from the copyed object)deep copy (copy whole objects including the nested objects)In ruby, dup or clone are both shallow copyx1 = { :title => 'supervisor_1', :article => ['article_1', 'article_2'], :confidential => ['confidential_1', 'confidential_2']}x2 = x1.clonex2[:title] = 'supervisor_2'puts x1 # the title unchangedputs x2If we change the nested value as follow:x1 = { :title => 'supervisor_1', :article => ['article_1', 'article_2'], :confidential => ['confidential_1', 'confidential_2']}x2 = x1.clonex2[:article][0] = 'hahahaha'puts x1 # the article of x1 also changedputs x2To avoid it, we use deep_dup in ActiveSupport from railsx1 = { :title => 'supervisor_1', :article => ['article_1', 'article_2'], :confidential => ['confidential_1', 'confidential_2']}x2 = x1.deep_dupx2[:article][0] = 'hahahaha'puts x1 # the article of x1 not changedputs x2design graph and pseudocodeThe code in section, Demonstration, is for one document. We can extend this design for more documents as following design graph and pseudocodedesign graph#mark83984{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark83984 .error-icon{fill:#552222;}#mark83984 .error-text{fill:#552222;stroke:#552222;}#mark83984 .edge-thickness-normal{stroke-width:2px;}#mark83984 .edge-thickness-thick{stroke-width:3.5px;}#mark83984 .edge-pattern-solid{stroke-dasharray:0;}#mark83984 .edge-pattern-dashed{stroke-dasharray:3;}#mark83984 .edge-pattern-dotted{stroke-dasharray:2;}#mark83984 .marker{fill:#333333;stroke:#333333;}#mark83984 .marker.cross{stroke:#333333;}#mark83984 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark83984 g.classGroup text{fill:#9370DB;fill:#131300;stroke:none;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:10px;}#mark83984 g.classGroup text .title{font-weight:bolder;}#mark83984 .nodeLabel,#mark83984 .edgeLabel{color:#131300;}#mark83984 .edgeLabel .label rect{fill:#ECECFF;}#mark83984 .label text{fill:#131300;}#mark83984 .edgeLabel .label span{background:#ECECFF;}#mark83984 .classTitle{font-weight:bolder;}#mark83984 .node rect,#mark83984 .node circle,#mark83984 .node ellipse,#mark83984 .node polygon,#mark83984 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark83984 .divider{stroke:#9370DB;stroke-width:1;}#mark83984 g.clickable{cursor:pointer;}#mark83984 g.classGroup rect{fill:#ECECFF;stroke:#9370DB;}#mark83984 g.classGroup line{stroke:#9370DB;stroke-width:1;}#mark83984 .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mark83984 .classLabel .label{fill:#9370DB;font-size:10px;}#mark83984 .relation{stroke:#333333;stroke-width:1;fill:none;}#mark83984 .dashed-line{stroke-dasharray:3;}#mark83984 .dotted-line{stroke-dasharray:1 2;}#mark83984 #compositionStart,#mark83984 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark83984 #compositionEnd,#mark83984 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark83984 #dependencyStart,#mark83984 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark83984 #dependencyStart,#mark83984 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark83984 #extensionStart,#mark83984 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark83984 #extensionEnd,#mark83984 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark83984 #aggregationStart,#mark83984 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark83984 #aggregationEnd,#mark83984 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark83984 #lollipopStart,#mark83984 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark83984 #lollipopEnd,#mark83984 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark83984 .edgeTerminals{font-size:11px;}#mark83984 .classTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark83984 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}CallInherited FromInherited FromClientPrototypeclone()DocumentOneFieldOneDocumentTwoFieldTwopseudocodeclass Prototype def clone endendclass ConfidentialReference ...endclass DocumentOne < Prototype def initialize @document = 'One' super end ...endclass DocumentTwo < Prototype def initialize @document = 'Two' super endendExampleIf we build the class intuitively, we may just create a class as follow:class Prototype attr_accessor :title, :articles, :confidentials def initialize @title = nil @articles = nil @confidentials = nil end def clone @articles = deep_copy(@articles) @confidentials = deep_copy(@confidentials) @confidentials.prototype = self deep_copy(self) end private def deep_copy(object) Marshal.load(Marshal.dump(object)) endendclass ConfidentialReference attr_accessor :prototype def initialize(prototype) @prototype = prototype endend# The client code.p1 = Prototype.newp1.title = 'supervisor_1'p1.articles = ['article_1']p1.confidentials = ConfidentialReference.new(p1)p2 = p1.clonep2.title = 'supervisor_2'# ============# checkp1.title != p2.title # for two different supervisorp1.articles.equal?(p2.articles) # two different articles with same contentp1.confidentials.equal?(p2.confidentials)p1.confidentials.prototype.equal?(p2.confidentials.prototype) # again two different confidential articles with same content, so if the information leaks, we know who did it.ReferencePrototype Design Pattern Tutorial[Design Pattern] Prototype 原型模式PrototypePython Shallow Copy and Deep Copy","url":"/blog/software/design-pattern/prototype"},{"title":"(design-pattern) Singleton","content":"(design-pattern) SingletonPurposeThe purpose is to let a class to create only one instance in the run time and provide a global point of access to that instance.ConceptYou should create a class having a method instance to check whether there is an instance created and all the global pointers point to that instance.class Singleton { constructor() { if (!Singleton.instance) { Singleton.instance = this; this.value = 0; } return Singleton.instance; } instance() { }}// Usageconst singleton1 = new Singleton();const singleton2 = new Singleton();console.log(singleton1 === singleton2); // Output will be true, as both instances refer to the same object.Real world exampleFor example, we only want a single logger to log the message, ensuring no concurrency caused by multiple logger.class Logger { constructor() { if (!Logger.instance) { Logger.instance = this; this.logs = []; } return Logger.instance; } log(message) { this.logs.push({ message, timestamp: new Date() }); console.log(message); } displayLogs() { this.logs.forEach(log => { console.log(`[${log.timestamp}] ${log.message}`); }); }}// Usageconst logger1 = new Logger();logger1.log(\"Log message 1\");const logger2 = new Logger();logger2.log(\"Log message 2\");logger1.displayLogs();ReferenceGPT","url":"/blog/software/design-pattern/singleton"},{"title":"(design-pattern) Abstract-factory","content":"(design-pattern) Abstract-factoryPurposeAbstract factory is the extension of factory method. Use the abstract factory pattern when you need to create families of related objects and ensure their compatibility, whereas the factory method pattern is suitable for creating individual objects with customization.ConceptRecap: We call the factory method to create same kind of product but choose different feature during the process of production.If we want the factory to create various product, we need the factory to have various product lines, which is the abstract factory design pattern.For example, let's say we want two environments, ocean and plain and two types of monsters, horse and fish. The horse monster is strong in plain but weak in ocean; the fish monster is strong in ocean but weak in plain. We need two factories for two environments. Each has two product lines.so the methods to create the monsters accroding to the envrionmnets would be as follow:def create_monsters(FactoryOcean.new)enddef create_monsters(FactoryPlain.new)endand the UML would be as follow:#mark57656{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark57656 .error-icon{fill:#552222;}#mark57656 .error-text{fill:#552222;stroke:#552222;}#mark57656 .edge-thickness-normal{stroke-width:2px;}#mark57656 .edge-thickness-thick{stroke-width:3.5px;}#mark57656 .edge-pattern-solid{stroke-dasharray:0;}#mark57656 .edge-pattern-dashed{stroke-dasharray:3;}#mark57656 .edge-pattern-dotted{stroke-dasharray:2;}#mark57656 .marker{fill:#333333;stroke:#333333;}#mark57656 .marker.cross{stroke:#333333;}#mark57656 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark57656 g.classGroup text{fill:#9370DB;fill:#131300;stroke:none;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:10px;}#mark57656 g.classGroup text .title{font-weight:bolder;}#mark57656 .nodeLabel,#mark57656 .edgeLabel{color:#131300;}#mark57656 .edgeLabel .label rect{fill:#ECECFF;}#mark57656 .label text{fill:#131300;}#mark57656 .edgeLabel .label span{background:#ECECFF;}#mark57656 .classTitle{font-weight:bolder;}#mark57656 .node rect,#mark57656 .node circle,#mark57656 .node ellipse,#mark57656 .node polygon,#mark57656 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark57656 .divider{stroke:#9370DB;stroke-width:1;}#mark57656 g.clickable{cursor:pointer;}#mark57656 g.classGroup rect{fill:#ECECFF;stroke:#9370DB;}#mark57656 g.classGroup line{stroke:#9370DB;stroke-width:1;}#mark57656 .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mark57656 .classLabel .label{fill:#9370DB;font-size:10px;}#mark57656 .relation{stroke:#333333;stroke-width:1;fill:none;}#mark57656 .dashed-line{stroke-dasharray:3;}#mark57656 .dotted-line{stroke-dasharray:1 2;}#mark57656 #compositionStart,#mark57656 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark57656 #compositionEnd,#mark57656 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark57656 #dependencyStart,#mark57656 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark57656 #dependencyStart,#mark57656 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark57656 #extensionStart,#mark57656 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark57656 #extensionEnd,#mark57656 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark57656 #aggregationStart,#mark57656 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark57656 #aggregationEnd,#mark57656 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark57656 #lollipopStart,#mark57656 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark57656 #lollipopEnd,#mark57656 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark57656 .edgeTerminals{font-size:11px;}#mark57656 .classTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark57656 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}is ais ais ais ais ais acreatecreatecreatecreateFishStrongFishWeakFishHorseStrongHorseWeakHorseAbstractFactoryFactoryOceancreate_strong_fish()create_weak_horse()FactoryPlaincreate_weak_fish()create_strong_horse()Exampleclass AbstractFactory def create_fish raise NotImplementedError, \"#{self.class} has not implemented method '#{__method__}'\" end def create_horse raise NotImplementedError, \"#{self.class} has not implemented method '#{__method__}'\" endendclass FactoryOcean < AbstractFactory def create_fish StrongFish.new end def create_horse WeakFish.new endendclass FactoryPlain < AbstractFactory def create_fish WeakFish.new end def create_horse StrongHorse.new endendclass Fish def power raise NotImplementedError, \"#{self.class} has not implemented method '#{__method__}'\" endendclass StrongFish < Fish def power 'strong fish' endendclass WeakFish < Fish def power 'weak fish' endendclass Horse def power raise NotImplementedError, \"#{self.class} has not implemented method '#{__method__}'\" endendclass StrongHorse < Horse def power 'strong horse' endendclass WeakHorse < Horse def power 'weak horse' endenddef create_monsters(factory) fish = factory.create_fish horse = factory.create_horse puts fish.power puts horse.powerendcreate_monsters(FactoryOcean.new)create_monsters(FactoryPlain.new)ReferenceAbstract Factory Pattern – Design Patterns (ep 5)","url":"/blog/software/design-pattern/abstract-factory"},{"title":"(design-pattern) Composite","content":"(design-pattern) CompositePurposeThe purpose of the composite design pattern is to compose objects into tree structures, allowing clients to treat individual objects and compositions uniformly.ConceptTreat them uniformlyWith this pattern, we can compose objects into part-whole hierarchies where object is composed of other objects, creating a hierarchy of components that can be treated uniformly. For instance, in a company organizational chart, individual employees form the \"parts,\" and departments or teams they belong to form the \"wholes\" – the hierarchy allows for consistent handling of both individual employees and entire departments.class Component { constructor(name) { this.name = name; } operation() { console.log(`Performing operation on ${this.name}`); }}class Composite extends Component { constructor(name) { super(name); this.children = []; } add(child) { this.children.push(child); } remove(child) { const index = this.children.indexOf(child); if (index !== -1) { this.children.splice(index, 1); } } operation() { console.log(`Performing operation on ${this.name}`); this.children.forEach(child => child.operation()); }}// Usageconst leaf1 = new Component(\"Leaf 1\");const leaf2 = new Component(\"Leaf 2\");const composite = new Composite(\"Composite\");composite.add(leaf1);composite.add(leaf2);const root = new Composite(\"Root\");root.add(composite);root.operation();// Performing operation on Root// Performing operation on Composite// Performing operation on Leaf 1// Performing operation on Leaf 2As you can see, the root operation will call the operation of root and then call the operation of composite and then call the operation of leaf 1 and leaf 2.Real world exampleReact","url":"/blog/software/design-pattern/composite"},{"title":"(design-pattern) Decorator","content":"(design-pattern) DecoratorPurposeTo change the behavior of a class without rewriting the code of the class by wrap the class with a class.How?Image your restaurant serves lots of beverages and you want to design tables to store necessary information in your computer. Intuitively, there are two way: using inheritance or using polymorphism; however, inheritance creates lots of tables with duplicate methods and polymorphism creates multiple columns which is unnecessary for most other tables. To solve it, we use the concept of decorator which is to decorate the base class.The UML:#mark16402{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark16402 .error-icon{fill:#552222;}#mark16402 .error-text{fill:#552222;stroke:#552222;}#mark16402 .edge-thickness-normal{stroke-width:2px;}#mark16402 .edge-thickness-thick{stroke-width:3.5px;}#mark16402 .edge-pattern-solid{stroke-dasharray:0;}#mark16402 .edge-pattern-dashed{stroke-dasharray:3;}#mark16402 .edge-pattern-dotted{stroke-dasharray:2;}#mark16402 .marker{fill:#333333;stroke:#333333;}#mark16402 .marker.cross{stroke:#333333;}#mark16402 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark16402 g.classGroup text{fill:#9370DB;fill:#131300;stroke:none;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:10px;}#mark16402 g.classGroup text .title{font-weight:bolder;}#mark16402 .nodeLabel,#mark16402 .edgeLabel{color:#131300;}#mark16402 .edgeLabel .label rect{fill:#ECECFF;}#mark16402 .label text{fill:#131300;}#mark16402 .edgeLabel .label span{background:#ECECFF;}#mark16402 .classTitle{font-weight:bolder;}#mark16402 .node rect,#mark16402 .node circle,#mark16402 .node ellipse,#mark16402 .node polygon,#mark16402 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark16402 .divider{stroke:#9370DB;stroke-width:1;}#mark16402 g.clickable{cursor:pointer;}#mark16402 g.classGroup rect{fill:#ECECFF;stroke:#9370DB;}#mark16402 g.classGroup line{stroke:#9370DB;stroke-width:1;}#mark16402 .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mark16402 .classLabel .label{fill:#9370DB;font-size:10px;}#mark16402 .relation{stroke:#333333;stroke-width:1;fill:none;}#mark16402 .dashed-line{stroke-dasharray:3;}#mark16402 .dotted-line{stroke-dasharray:1 2;}#mark16402 #compositionStart,#mark16402 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark16402 #compositionEnd,#mark16402 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark16402 #dependencyStart,#mark16402 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark16402 #dependencyStart,#mark16402 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark16402 #extensionStart,#mark16402 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark16402 #extensionEnd,#mark16402 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark16402 #aggregationStart,#mark16402 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark16402 #aggregationEnd,#mark16402 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark16402 #lollipopStart,#mark16402 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark16402 #lollipopEnd,#mark16402 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark16402 .edgeTerminals{font-size:11px;}#mark16402 .classTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark16402 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}is ais ais a & has ais ais aBeveragegetDesc()cost()Espressocost()Decafcost()DecoratorgetDesc()SoyMilkDecoratorgetDesc()cost()CaramelDecoratorgetDesc()cost()For example, the cost of Espresso is 2 dollar and the cost of SoyMilkDecorator is 1 dollar, so I would expect that espresso.cost = 2, SoyMilkDecorator.cost = 1, espresso_with_soymilk.cost = 3Exampleclass Beverage { get_desc() { throw new Error(`${this.constructor.name} has not implemented method '${this.get_desc.name}'`); } cost() { throw new Error(`${this.constructor.name} has not implemented method '${this.cost.name}'`); }}class Espresso extends Beverage { get_desc() { return 'Espresso'; } cost() { return 2; }}class Decaf extends Beverage { get_desc() { return 'Decaf'; } cost() { return 1; }}class Decorator extends Beverage { constructor(beverage) { super(); this.beverage = beverage; } get_desc() { return this.beverage.get_desc(); }}class SoyMilkDecorator extends Decorator { cost() { return this.beverage.cost() + 1; }}class CaramelDecorator extends Decorator { cost() { return this.beverage.cost() + 3; }}const espresso_with_soy_milk = new SoyMilkDecorator(new Espresso());console.log(espresso_with_soy_milk.cost()); // 3ReferenceDecorator Pattern – Design Patterns (ep 3)Decorator in Ruby","url":"/blog/software/design-pattern/decorator"},{"title":"(design-pattern) Adapter","content":"(design-pattern) AdapterPurposeAn adapter in software is used to either reuse an existing class with a different interface or to enable a class to work with multiple incompatible classes, while also providing abstraction to decouple client code from underlying class specifics.How?The Adapter pattern allows two incompatible interfaces to work together by creating a class that acts as an interface between them. The adapter class maps the methods of one interface to another, making it possible for the two interfaces to communicate.Three componentsClient: The client is the component that is trying to use the adaptee, but cannot do so directly because the adaptee's interface is incompatible with the client's interfaceAdapter: The adapter is a class that acts as a bridge between the client and the adaptee. It maps the methods of the adaptee to the methods of the client.Adaptee: The adaptee is the component that the client wants to use, but cannot do so directly because its interface is incompatible with the client's interface.example in javascriptLet's say there are two different payment system and we need to store the logs on different services.// First Adaptee - the complex class that needs to be adaptedclass LegacyPaymentProcessor { constructor() { this.total = 0 } addPayment(amount) { this.total += amount console.log('add payment, log to legacy') } getTotal() { return this.total console.log('get total, log to legacy') }}// Second Adaptee - another complex class that needs to be adaptedclass ModernPaymentProcessor { constructor() { this.total = 0; } addPayment(amount) { this.total += amount; console.log('add payment, log to modern') } getTotal() { return this.total; console.log('get total, log to modern') }}// Adapter - the class that adapts the interface of the Adapteesclass PaymentAdapter { constructor(adaptee) { this.adaptee = adaptee; } processPayment(amount) { this.adaptee.addPayment(amount); } getTotal() { this.adaptee.getTotal(); }}// Client code that uses the PaymentAdapter with two Adapteesconst legacyPaymentProcessor = new LegacyPaymentProcessor();const modernPaymentProcessor = new ModernPaymentProcessor();const paymentAdapter1 = new PaymentAdapter(legacyPaymentProcessor);const paymentAdapter2 = new PaymentAdapter(modernPaymentProcessor);paymentAdapter1.processPayment(100);paymentAdapter2.processPayment(100);ExampleActive record in railsReferenceChatGPT","url":"/blog/software/design-pattern/adapter"},{"title":"(design-pattern) Proxy","content":"(design-pattern) ProxyPurposeThe proxy pattern is utilized to manage object access. If some issues like security, resources and caching occurs, it do not let us use that objects, without altering the core object's structure. This promotes efficient resource utilization and improved system performance.ConceptThe core concept is to create a surrogate or placeholder object that acts as a representative for another object, controlling access to it and allowing additional functionality to be added without altering the original object's interface.ExampleFor example, if we want to have different authorization of database on different roles, we can use the proxy pattern to achieve it. In the following example, the ProxyDatabase class controls access to the real RealDatabase. Only users listed in the authorizedUsers array are allowed to read or write data using the proxy. If a user is not authorized, appropriate messages are displayed, preventing unauthorized access to the database.class RealDatabase { constructor() { this.data = {}; } readData(key) { return this.data[key]; } writeData(key, value) { this.data[key] = value; }}class ProxyDatabase { constructor() { this.realDatabase = new RealDatabase(); this.authorizedUsers = [\"admin\", \"manager\"]; } readData(key, user) { if (this.authorizedUsers.includes(user)) { return this.realDatabase.readData(key); } else { console.log(`User ${user} is not authorized to read data.`); return null; } } writeData(key, value, user) { if (this.authorizedUsers.includes(user)) { this.realDatabase.writeData(key, value); console.log(`User ${user} wrote data: ${key} => ${value}`); } else { console.log(`User ${user} is not authorized to write data.`); } }}// Usageconst databaseProxy = new ProxyDatabase();databaseProxy.writeData(\"name\", \"John\", \"admin\"); // Successful writedatabaseProxy.writeData(\"age\", 25, \"user\"); // Unauthorized writeconsole.log(databaseProxy.readData(\"name\", \"manager\")); // Johnconsole.log(databaseProxy.readData(\"age\", \"user\")); // User user is not authorized to read data.","url":"/blog/software/design-pattern/proxy"},{"title":"(design-pattern) Facade","content":"(design-pattern) FacadePurposeWe only care about the aspects we care; for example, given a delivery system, user cares when the package arrives and the cost.Even thought the process of delivering involves shippings, air transport, ...etc and it is truly complicate, we do not care. We should prepare the system to have clean interfaces (facades) for them to acquire the information they want.ConceptThis patternmakes my code prettier just like facade increase the taste of my house even thought my house is messybelongs to structural patterns, so it structures a specific kind of objectsdeal with complex set of objects, which these objects did not follow any particular structure; they should be messyExampleFor example, there are multiple services:service for transportation: OceanShippingService, AirTransportationService, LandTransportationServiceservice to evaluate whether this item is deliverable: Packageservice to return possible routes: RouteActually we only care the possible choices of time and cost, so## The facade class and the inputs: start, destination, itemWhatWeCare.new('Taichung', 'Taipei', 'Chihuahua').result## example outputs: (when it arrives, cost)[ ['60 mins', 1000], ['30 mins', 2000],]WhatWeCare is a facade as follow: (pseudocode)class WhatWeCare { constructor(origin, destination, item) { this.origin = origin; this.destination = destination; this.item = item; } result() { return new Route(this.origin, this.destination).results.map((route) => { if (route.is_deliverable()) { return [ this.when_it_arrives(route), this.cost(route) ]; } }); } when_it_arrives(route) { const result = []; route.forEach((sub_route) => { switch (sub_route.type) { case 'Air': result.push(new AirTransportationService(sub_route).time); break; case 'Land': result.push(new LandTransportationService(sub_route).time); break; case 'Ocean': result.push(new OceanTransportationService(sub_route).time); break; } }); return result.reduce((sum, time) => sum + time, 0); } cost(route) { const result = []; route.forEach((sub_route) => { switch (sub_route.type) { case 'Air': result.push(new AirTransportationService(sub_route).cost); break; case 'Land': result.push(new LandTransportationService(sub_route).cost); break; case 'Ocean': result.push(new OceanTransportationService(sub_route).cost); break; } }); return result.reduce((sum, cost) => sum + cost, 0); } routes() { return new Route(this.origin, this.destination); }}given the service as follow:class Route { constructor(origin, destination) { // Initialize route with origin and destination // ... } results() { return this.possible_routes().filter((route) => { if (this.is_deliverable(route)) { return route; } }); } possible_routes() { // Define possible routes return [ ['Taichung to Taoyuan (Air)', 'Taoyuan to Taipei (Ocean)'], ['Taichung to Hsinchu (Air)', 'Hsinchu to Banqiao (Ocean)', 'Banqiao to Taipei (Ocean)'], // ... ]; } is_deliverable(route) { return new Package(route).result(); }}class Package { constructor(route) { // Initialize package with route // ... } result() { // Determine if the item is deliverable in this sub-route // Return true or false }}class OceanShippingService { constructor(route) { // Initialize service with route // ... } time() { // Return estimated delivery time } cost() { // Return estimated delivery cost }}class AirTransportationService { constructor() { // Initialize service // ... } time() { // Return estimated delivery time } cost() { // Return estimated delivery cost }}class LandTransportationService { constructor() { // Initialize service // ... } time() { // Return estimated delivery time } cost() { // Return estimated delivery cost }}ReferenceFacadeFacade Pattern – Design Patterns (ep 9)","url":"/blog/software/design-pattern/facade"},{"title":"(design-pattern) Observer","content":"(design-pattern) ObserverPurposeThe purpose of using the observer pattern is to establish a one-to-many dependency between objects, ensuring that when one object changes its state, all its dependents are automatically notified and updated.ConceptApple fans really want new iphone, so they keep visiting store everyday to check whether new iphone released. The company feels disturbed, so they decided to send the release information through advertisements and broadcasts. But in this time, people not interested complain that they do not want to see this information.#mark92854{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark92854 .error-icon{fill:#552222;}#mark92854 .error-text{fill:#552222;stroke:#552222;}#mark92854 .edge-thickness-normal{stroke-width:2px;}#mark92854 .edge-thickness-thick{stroke-width:3.5px;}#mark92854 .edge-pattern-solid{stroke-dasharray:0;}#mark92854 .edge-pattern-dashed{stroke-dasharray:3;}#mark92854 .edge-pattern-dotted{stroke-dasharray:2;}#mark92854 .marker{fill:#333333;stroke:#333333;}#mark92854 .marker.cross{stroke:#333333;}#mark92854 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark92854 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark92854 .cluster-label text{fill:#333;}#mark92854 .cluster-label span,#mark92854 p{color:#333;}#mark92854 .label text,#mark92854 span,#mark92854 p{fill:#333;color:#333;}#mark92854 .node rect,#mark92854 .node circle,#mark92854 .node ellipse,#mark92854 .node polygon,#mark92854 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark92854 .flowchart-label text{text-anchor:middle;}#mark92854 .node .label{text-align:center;}#mark92854 .node.clickable{cursor:pointer;}#mark92854 .arrowheadPath{fill:#333333;}#mark92854 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark92854 .flowchart-link{stroke:#333333;fill:none;}#mark92854 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark92854 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark92854 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark92854 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark92854 .cluster text{fill:#333;}#mark92854 .cluster span,#mark92854 p{color:#333;}#mark92854 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark92854 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark92854 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}visitvisitvisitvisitfan 1apple storefan 2fan 3fan 4Bad solution: (broadcast randomly), which will notify someone not interested or skip some fans#mark95169{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark95169 .error-icon{fill:#552222;}#mark95169 .error-text{fill:#552222;stroke:#552222;}#mark95169 .edge-thickness-normal{stroke-width:2px;}#mark95169 .edge-thickness-thick{stroke-width:3.5px;}#mark95169 .edge-pattern-solid{stroke-dasharray:0;}#mark95169 .edge-pattern-dashed{stroke-dasharray:3;}#mark95169 .edge-pattern-dotted{stroke-dasharray:2;}#mark95169 .marker{fill:#333333;stroke:#333333;}#mark95169 .marker.cross{stroke:#333333;}#mark95169 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark95169 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark95169 .cluster-label text{fill:#333;}#mark95169 .cluster-label span,#mark95169 p{color:#333;}#mark95169 .label text,#mark95169 span,#mark95169 p{fill:#333;color:#333;}#mark95169 .node rect,#mark95169 .node circle,#mark95169 .node ellipse,#mark95169 .node polygon,#mark95169 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark95169 .flowchart-label text{text-anchor:middle;}#mark95169 .node .label{text-align:center;}#mark95169 .node.clickable{cursor:pointer;}#mark95169 .arrowheadPath{fill:#333333;}#mark95169 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark95169 .flowchart-link{stroke:#333333;fill:none;}#mark95169 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark95169 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark95169 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark95169 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark95169 .cluster text{fill:#333;}#mark95169 .cluster span,#mark95169 p{color:#333;}#mark95169 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark95169 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark95169 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}broadcastbroadcastbroadcastbroadcastbroadcastapple storefan 1fan 2bystander 1fan 4...To solve this problem, Apple lets people visiting store for new iphone information to leave email so that the company can send notifications to these people when new iphone released. The notification is just like observer pattern.Better solution:#mark16239{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark16239 .error-icon{fill:#552222;}#mark16239 .error-text{fill:#552222;stroke:#552222;}#mark16239 .edge-thickness-normal{stroke-width:2px;}#mark16239 .edge-thickness-thick{stroke-width:3.5px;}#mark16239 .edge-pattern-solid{stroke-dasharray:0;}#mark16239 .edge-pattern-dashed{stroke-dasharray:3;}#mark16239 .edge-pattern-dotted{stroke-dasharray:2;}#mark16239 .marker{fill:#333333;stroke:#333333;}#mark16239 .marker.cross{stroke:#333333;}#mark16239 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark16239 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark16239 .cluster-label text{fill:#333;}#mark16239 .cluster-label span,#mark16239 p{color:#333;}#mark16239 .label text,#mark16239 span,#mark16239 p{fill:#333;color:#333;}#mark16239 .node rect,#mark16239 .node circle,#mark16239 .node ellipse,#mark16239 .node polygon,#mark16239 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark16239 .flowchart-label text{text-anchor:middle;}#mark16239 .node .label{text-align:center;}#mark16239 .node.clickable{cursor:pointer;}#mark16239 .arrowheadPath{fill:#333333;}#mark16239 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark16239 .flowchart-link{stroke:#333333;fill:none;}#mark16239 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark16239 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark16239 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark16239 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark16239 .cluster text{fill:#333;}#mark16239 .cluster span,#mark16239 p{color:#333;}#mark16239 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark16239 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark16239 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}BroadcastObserver Patternobservesbroadcastbroadcastbroadcastbroadcastfan 1fan 2fan 3...other fansapple storeobserverOne to many relationship (one observable (apple store) to many observers (fans))The state of observable changed and all observers are notified#mark38841{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark38841 .error-icon{fill:#552222;}#mark38841 .error-text{fill:#552222;stroke:#552222;}#mark38841 .edge-thickness-normal{stroke-width:2px;}#mark38841 .edge-thickness-thick{stroke-width:3.5px;}#mark38841 .edge-pattern-solid{stroke-dasharray:0;}#mark38841 .edge-pattern-dashed{stroke-dasharray:3;}#mark38841 .edge-pattern-dotted{stroke-dasharray:2;}#mark38841 .marker{fill:#333333;stroke:#333333;}#mark38841 .marker.cross{stroke:#333333;}#mark38841 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark38841 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark38841 .cluster-label text{fill:#333;}#mark38841 .cluster-label span,#mark38841 p{color:#333;}#mark38841 .label text,#mark38841 span,#mark38841 p{fill:#333;color:#333;}#mark38841 .node rect,#mark38841 .node circle,#mark38841 .node ellipse,#mark38841 .node polygon,#mark38841 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark38841 .flowchart-label text{text-anchor:middle;}#mark38841 .node .label{text-align:center;}#mark38841 .node.clickable{cursor:pointer;}#mark38841 .arrowheadPath{fill:#333333;}#mark38841 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark38841 .flowchart-link{stroke:#333333;fill:none;}#mark38841 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark38841 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark38841 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark38841 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark38841 .cluster text{fill:#333;}#mark38841 .cluster span,#mark38841 p{color:#333;}#mark38841 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark38841 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark38841 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}push: I changed statuspush: I changed statuspush: I changed statusObservableobserversobservers...and the UML (suppose fans can receive release information through phone and computer)#mark47993{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark47993 .error-icon{fill:#552222;}#mark47993 .error-text{fill:#552222;stroke:#552222;}#mark47993 .edge-thickness-normal{stroke-width:2px;}#mark47993 .edge-thickness-thick{stroke-width:3.5px;}#mark47993 .edge-pattern-solid{stroke-dasharray:0;}#mark47993 .edge-pattern-dashed{stroke-dasharray:3;}#mark47993 .edge-pattern-dotted{stroke-dasharray:2;}#mark47993 .marker{fill:#333333;stroke:#333333;}#mark47993 .marker.cross{stroke:#333333;}#mark47993 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark47993 g.classGroup text{fill:#9370DB;fill:#131300;stroke:none;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:10px;}#mark47993 g.classGroup text .title{font-weight:bolder;}#mark47993 .nodeLabel,#mark47993 .edgeLabel{color:#131300;}#mark47993 .edgeLabel .label rect{fill:#ECECFF;}#mark47993 .label text{fill:#131300;}#mark47993 .edgeLabel .label span{background:#ECECFF;}#mark47993 .classTitle{font-weight:bolder;}#mark47993 .node rect,#mark47993 .node circle,#mark47993 .node ellipse,#mark47993 .node polygon,#mark47993 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark47993 .divider{stroke:#9370DB;stroke-width:1;}#mark47993 g.clickable{cursor:pointer;}#mark47993 g.classGroup rect{fill:#ECECFF;stroke:#9370DB;}#mark47993 g.classGroup line{stroke:#9370DB;stroke-width:1;}#mark47993 .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mark47993 .classLabel .label{fill:#9370DB;font-size:10px;}#mark47993 .relation{stroke:#333333;stroke-width:1;fill:none;}#mark47993 .dashed-line{stroke-dasharray:3;}#mark47993 .dotted-line{stroke-dasharray:1 2;}#mark47993 #compositionStart,#mark47993 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark47993 #compositionEnd,#mark47993 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark47993 #dependencyStart,#mark47993 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark47993 #dependencyStart,#mark47993 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark47993 #extensionStart,#mark47993 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark47993 #extensionEnd,#mark47993 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark47993 #aggregationStart,#mark47993 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark47993 #aggregationEnd,#mark47993 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark47993 #lollipopStart,#mark47993 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark47993 #lollipopEnd,#mark47993 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark47993 .edgeTerminals{font-size:11px;}#mark47993 .classTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark47993 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}has manyis ais ais aInterfaceObservableadd(observer)remove(observer)notify()InterfaceObserverupdate()StoreObservableadd(InterfaceObserver)remove(InterfaceObserver)notify()business_logic()StoreObserverAupdate()StoreObserverBupdate()update: How observer reacts to observable eventsadd: Let observers to observeremove: disable observers to observenotify: how observable object want observers to reactbusiness_logic: the business logic of observable and observers can react accordinglyPros and ConsprosOpen/Closed Principle. You can introduce new observers classes without having to change the observable’s code (and vice versa).consSubscribers are notified in random order.Exampleclass InterfaceObservable { add(observer) { throw new Error(`${this.constructor.name} has not implemented method 'add'`); } remove(observer) { throw new Error(`${this.constructor.name} has not implemented method 'remove'`); } notify() { throw new Error(`${this.constructor.name} has not implemented method 'notify'`); }}class InterfaceObserver { update(_subject) { throw new Error(`${this.constructor.name} has not implemented method 'update'`); }}class StoreObservable extends InterfaceObservable { constructor() { super(); this.state = null; this.observers = []; } add(observer) { this.observers.push(observer); } remove(observer) { const index = this.observers.indexOf(observer); if (index !== -1) { this.observers.splice(index, 1); } } notify() { this.observers.forEach(observer => observer.update(this)); } businessLogic() { this.state = ['new iphone released', 'no new iphone released'][Math.floor(Math.random() * 2)]; // simulate the business logic going to change the state of the observable console.log(`Subject: My state has just changed to: ${this.state}`); this.notify(); }}class StoreObserverA extends InterfaceObserver { update(subject) { console.log(`Inform A: ${subject.state}`); }}class StoreObserverB extends InterfaceObserver { update(subject) { console.log(`Inform B: ${subject.state}`); }}// the implementationconst storeObservable = new StoreObservable();const storeObserverA = new StoreObserverA();const storeObserverB = new StoreObserverB();// let observer observe the observablestoreObservable.add(storeObserverA);storeObservable.add(storeObserverB);// the states of the observers will change according to the state of store observablestoreObservable.businessLogic();storeObservable.businessLogic();storeObservable.remove(storeObserverA);// observer A will not be notifiedstoreObservable.businessLogic();What we can do more:add methods to specify informing methods in StoreObserver; for example, use phone for StoreObserverA and use computer for StoreObserverBadd methods to specify when to inform StoreObserver; for example, only particular events or particular timingReferenceObserver Pattern – Design Patterns (ep 2)Observer in RubyObserver","url":"/blog/software/design-pattern/observer"},{"title":"(design-pattern) Strategy","content":"(design-pattern) StrategyWhy?We do not want to rewrite the same methods in different lower classes.How?Constructs multiple intefaces for variant methods in a upper class so that we can have multiple combinations to create multiple classes inherit from this upper class with shared methods.For example, given lots of varieties of dogs, there are four dogs with different behaviors according to their characteristics:stupid dog: walks for losing its waysmart dog: walks to anywhere it wantanxious dog: kiss their owner for stroking to feel relievedcalm dog: kiss their owner to express intimacyGiven the characteristics above we may have four type of dogs:stupid and anxious dog: Chihuahuastupid and calm dog: Bulldogsmart and anxious dog: Sheepdogssmart and calm dog: RetrieverGiven the OOP concepts, we have choices as follow:create an upper class and then create four classes inherit from itcreate an polymorhpic class with four typeGiven the four characteristics map four behaviors, we need to write logics or overwrite the methods in the upper class. What if we want Chihuahua to share their kissing behavior with Sheepdogs? We need the concept of strategy and the UML as follow:#mark62071{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark62071 .error-icon{fill:#552222;}#mark62071 .error-text{fill:#552222;stroke:#552222;}#mark62071 .edge-thickness-normal{stroke-width:2px;}#mark62071 .edge-thickness-thick{stroke-width:3.5px;}#mark62071 .edge-pattern-solid{stroke-dasharray:0;}#mark62071 .edge-pattern-dashed{stroke-dasharray:3;}#mark62071 .edge-pattern-dotted{stroke-dasharray:2;}#mark62071 .marker{fill:#333333;stroke:#333333;}#mark62071 .marker.cross{stroke:#333333;}#mark62071 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark62071 g.classGroup text{fill:#9370DB;fill:#131300;stroke:none;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:10px;}#mark62071 g.classGroup text .title{font-weight:bolder;}#mark62071 .nodeLabel,#mark62071 .edgeLabel{color:#131300;}#mark62071 .edgeLabel .label rect{fill:#ECECFF;}#mark62071 .label text{fill:#131300;}#mark62071 .edgeLabel .label span{background:#ECECFF;}#mark62071 .classTitle{font-weight:bolder;}#mark62071 .node rect,#mark62071 .node circle,#mark62071 .node ellipse,#mark62071 .node polygon,#mark62071 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark62071 .divider{stroke:#9370DB;stroke-width:1;}#mark62071 g.clickable{cursor:pointer;}#mark62071 g.classGroup rect{fill:#ECECFF;stroke:#9370DB;}#mark62071 g.classGroup line{stroke:#9370DB;stroke-width:1;}#mark62071 .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mark62071 .classLabel .label{fill:#9370DB;font-size:10px;}#mark62071 .relation{stroke:#333333;stroke-width:1;fill:none;}#mark62071 .dashed-line{stroke-dasharray:3;}#mark62071 .dotted-line{stroke-dasharray:1 2;}#mark62071 #compositionStart,#mark62071 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark62071 #compositionEnd,#mark62071 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark62071 #dependencyStart,#mark62071 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark62071 #dependencyStart,#mark62071 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark62071 #extensionStart,#mark62071 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark62071 #extensionEnd,#mark62071 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark62071 #aggregationStart,#mark62071 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark62071 #aggregationEnd,#mark62071 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark62071 #lollipopStart,#mark62071 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark62071 #lollipopEnd,#mark62071 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark62071 .edgeTerminals{font-size:11px;}#mark62071 .classTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark62071 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}InheritInheritInheritInheritComposeComposeInheritInheritInheritInheritDogChihuahuaBulldogSheepdogsRetrieverKissBehaviorkiss()WalkBehaviorwalk()KissForStrokingkiss()KissForIntimacykiss()WalkForLostwalk()walkToAnywherewalk()What?class Dog { constructor(walkBehavior, kissBehavior) { this.walkBehavior = walkBehavior; this.kissBehavior = kissBehavior; } kiss() { console.log(this.kissBehavior.kiss()); } walk() { console.log(this.walkBehavior.walk()); }}class KissBehavior { kiss() { throw new Error('Must'); }}class WalkBehavior { walk() { throw new Error('Must'); }}class KissForStroking extends KissBehavior { kiss() { return \"kiss for stroking\"; }}class KissForIntimacy extends KissBehavior { kiss() { return \"kiss for intimacy\"; }}class WalkForLost extends WalkBehavior { walk() { return \"walk for lost\"; }}class WalkToAnyWhere extends WalkBehavior { walk() { return \"walk to anywhere\"; }}and create instance from these four classeschihuahua = Dog.new(WalkForLost.new, KissBehavior.new)chihuahua.walkchihuahua.kissReferenceStrategy Pattern – Design Patterns (ep 1)","url":"/blog/software/design-pattern/strategy"},{"title":"(design-pattern) Visitor","content":"(design-pattern) VisitorPurposeThe purpose of using the visitor pattern is to separate algorithms from the objects on which they operate, allowing new operations to be added without modifying the objects' structure.ConceptThe Structure:sourceTo call methods in visitor pattern, we need accept in Element interfaceBy modifying the common operations method in visitor pattern, all objects using the common operations behaves consistently.pros:Open/Closed Principle: we can introduce new methods to objects without changing the classes of these objectsSingle Responsibility Principle: we can define related operations in one classvisitor object collects common information in one class, easier to compare different behaviorscons:When number of objects changes, we need to update all the common operationsExamplewhen a customer walk into a restaurant, we want both manager and clerk togreet with special slogan and self introductionsserve meals with same movement and different kind of professionsWith visitor pattern, we can change special slogan and movement day by day without break the classes of objects.class Employee { accept(visitor) { throw new Error(`${this.constructor.name} has not implemented method '${arguments.callee.name}'`); }}class Manager extends Employee { accept(visitor) { visitor.manager(this); } get status() { return 'Manager'; } get profession() { return 'order meal'; }}class Clerk extends Employee { accept(visitor) { visitor.clerk(this); } get status() { return 'Clerk'; } get profession() { return 'make meal'; }}class Visitor { manager(_element) { throw new Error(`${this.constructor.name} has not implemented method '${arguments.callee.name}'`); } clerk(_element) { throw new Error(`${this.constructor.name} has not implemented method '${arguments.callee.name}'`); }}class SayHi extends Visitor { manager(element) { console.log(`${this.specialSlogan()}, I am ${element.status}`); } clerk(element) { console.log(`${this.specialSlogan()}, I am ${element.status}`); } specialSlogan() { return 'Special Slogan this week!'; }}class ServeMeal extends Visitor { manager(element) { console.log(`${this.samePose()}, and then ${element.profession}`); } clerk(element) { console.log(`${this.samePose()}, and then ${element.profession}`); } samePose() { return 'dance dance dance'; }}function clientCode(components, visitor) { components.forEach(component => { component.accept(visitor); });}const components = [new Manager(), new Clerk()];const sayHi = new SayHi();clientCode(components, sayHi);const serveMeal = new ServeMeal();clientCode(components, serveMeal);Also, we separate these classes via inherit from Employee and Visitor, which achieves SOLID.Reference[ Day 25 ] 每個人關心的點都不同 - 訪問者模式 (Visitor Pattern)The Visitor Pattern Explained and Implemented in Java Behavioral Design Patterns GeekificVisitor","url":"/blog/software/design-pattern/visitor"},{"title":"(design-pattern) Command","content":"(design-pattern) CommandPurposeWith command pattern, we can wrap operations into stand-alone objects in which we canchange remote control (invoker)queue series commands (not every language supports metaprogramming)we can also store them in database, not only RAMreverse commands (unexecute)Concept#mark26764{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark26764 .error-icon{fill:#552222;}#mark26764 .error-text{fill:#552222;stroke:#552222;}#mark26764 .edge-thickness-normal{stroke-width:2px;}#mark26764 .edge-thickness-thick{stroke-width:3.5px;}#mark26764 .edge-pattern-solid{stroke-dasharray:0;}#mark26764 .edge-pattern-dashed{stroke-dasharray:3;}#mark26764 .edge-pattern-dotted{stroke-dasharray:2;}#mark26764 .marker{fill:#333333;stroke:#333333;}#mark26764 .marker.cross{stroke:#333333;}#mark26764 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark26764 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mark26764 .cluster-label text{fill:#333;}#mark26764 .cluster-label span,#mark26764 p{color:#333;}#mark26764 .label text,#mark26764 span,#mark26764 p{fill:#333;color:#333;}#mark26764 .node rect,#mark26764 .node circle,#mark26764 .node ellipse,#mark26764 .node polygon,#mark26764 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark26764 .flowchart-label text{text-anchor:middle;}#mark26764 .node .label{text-align:center;}#mark26764 .node.clickable{cursor:pointer;}#mark26764 .arrowheadPath{fill:#333333;}#mark26764 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mark26764 .flowchart-link{stroke:#333333;fill:none;}#mark26764 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mark26764 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mark26764 .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mark26764 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mark26764 .cluster text{fill:#333;}#mark26764 .cluster span,#mark26764 p{color:#333;}#mark26764 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mark26764 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark26764 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}commandsusecommandsthroughusecommandsthroughinheritfrominheritfromsendcommandtoInterfaceCommandConcreteCommand2ConcreteCommand1InvokerReceiverInvoker can be anything. We can attach the ConcreteCommand to any button such as a remote controller.ConcreteCommands in a particular invoker can request commands to more than one receiver or no receiver#mark2068{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mark2068 .error-icon{fill:#552222;}#mark2068 .error-text{fill:#552222;stroke:#552222;}#mark2068 .edge-thickness-normal{stroke-width:2px;}#mark2068 .edge-thickness-thick{stroke-width:3.5px;}#mark2068 .edge-pattern-solid{stroke-dasharray:0;}#mark2068 .edge-pattern-dashed{stroke-dasharray:3;}#mark2068 .edge-pattern-dotted{stroke-dasharray:2;}#mark2068 .marker{fill:#333333;stroke:#333333;}#mark2068 .marker.cross{stroke:#333333;}#mark2068 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mark2068 g.classGroup text{fill:#9370DB;fill:#131300;stroke:none;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:10px;}#mark2068 g.classGroup text .title{font-weight:bolder;}#mark2068 .nodeLabel,#mark2068 .edgeLabel{color:#131300;}#mark2068 .edgeLabel .label rect{fill:#ECECFF;}#mark2068 .label text{fill:#131300;}#mark2068 .edgeLabel .label span{background:#ECECFF;}#mark2068 .classTitle{font-weight:bolder;}#mark2068 .node rect,#mark2068 .node circle,#mark2068 .node ellipse,#mark2068 .node polygon,#mark2068 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mark2068 .divider{stroke:#9370DB;stroke-width:1;}#mark2068 g.clickable{cursor:pointer;}#mark2068 g.classGroup rect{fill:#ECECFF;stroke:#9370DB;}#mark2068 g.classGroup line{stroke:#9370DB;stroke-width:1;}#mark2068 .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mark2068 .classLabel .label{fill:#9370DB;font-size:10px;}#mark2068 .relation{stroke:#333333;stroke-width:1;fill:none;}#mark2068 .dashed-line{stroke-dasharray:3;}#mark2068 .dotted-line{stroke-dasharray:1 2;}#mark2068 #compositionStart,#mark2068 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark2068 #compositionEnd,#mark2068 .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark2068 #dependencyStart,#mark2068 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark2068 #dependencyStart,#mark2068 .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mark2068 #extensionStart,#mark2068 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark2068 #extensionEnd,#mark2068 .extension{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark2068 #aggregationStart,#mark2068 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark2068 #aggregationEnd,#mark2068 .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark2068 #lollipopStart,#mark2068 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark2068 #lollipopEnd,#mark2068 .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mark2068 .edgeTerminals{font-size:11px;}#mark2068 .classTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mark2068 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}Invokercommand+setCommand(command)+executeCommand()Receivermethods()ConcreteCommandreceivercommands+execute(command)+unexecute(command)prosSingle Responsibility Principle. Decouple invoking operations from performing operationsOpen/Closed Principle. Introduce new commands without breaking existing client codereversible commandscan store the commands as parameters -> store them -> execute them later or on particular timedecompose commands as meticulous as possible and reassemble them to other complex commandsconsmay creates too detailed and too many classes for commandsExampleFor example, a robot performs a serial movements to dance: right leg, left leg, head, butt and we can write a script as follow:class Robot { constructor() { } moveRightLeg() { console.log('move right leg'); } moveLeftLeg() { console.log('move left leg'); } moveHead() { console.log('move head'); } moveButt() { console.log('move butt'); } // ... other movements}const robot = new Robot();robot.moveRightLeg();robot.moveLeftLeg();robot.moveHead();robot.moveButt();With command pattern, we can achieve properties:change remote control (invoker)queue series commandscan reverse command (unexecute)class Robot { constructor() { } moveRightLeg() { console.log('move right leg'); } moveLeftLeg() { console.log('move left leg'); } moveHead() { console.log('move head'); } undoRightLeg() { console.log('undo right leg'); } undoLeftLeg() { console.log('undo left leg'); } undoHead() { console.log('undo head'); } // ... other movements}class Command { execute() { throw new Error(`${this.constructor.name} has not implemented method 'execute'`); } unexecute() { throw new Error(`${this.constructor.name} has not implemented method 'unexecute'`); }}class CustomCommand extends Command { constructor(receiver, commands) { super(); this.receiver = receiver; this.commands = commands; } execute() { this.commands.forEach(command => { switch (command) { case 'move_right_leg': this.receiver.moveRightLeg(); break; case 'move_left_leg': this.receiver.moveLeftLeg(); break; case 'move_head': this.receiver.moveHead(); break; // Add cases for other movements } }); } unexecute() { this.commands.reverse().forEach(command => { switch (command) { case 'move_right_leg': this.receiver.undoRightLeg(); break; case 'move_left_leg': this.receiver.undoLeftLeg(); break; case 'move_head': this.receiver.undoHead(); break; // Add cases for undoing other movements } }); }}class HeadCommand extends Command { constructor(receiver) { super(); this.receiver = receiver; } execute() { this.receiver.moveHead(); } unexecute() { this.receiver.undoHead(); }}class Invoker { constructor() { this.history = []; } set onPressCustomButton(commands) { this.onPressCustomButton = commands; } set onPressHeadButton(command) { this.onPressHeadButton = command; } executeCustomCommand() { if (this.onPressCustomButton instanceof Command) { this.onPressCustomButton.execute(); this.history.push(this.onPressCustomButton); } } executeHeadCommand() { if (this.onPressHeadButton instanceof Command) { this.onPressHeadButton.execute(); this.history.push(this.onPressHeadButton); } } undo() { console.log(this.history); const command = this.history.pop(); if (command) { command.unexecute(); } }}const invoker = new Invoker();const receiver = new Robot();invoker.onPressCustomButton = new CustomCommand(receiver, ['move_right_leg', 'move_left_leg']);invoker.onPressHeadButton = new HeadCommand(receiver);invoker.executeCustomCommand();// results// move right leg// move left leginvoker.undo();// results// undo left leg// undo right leginvoker.executeCustomCommand();invoker.executeHeadCommand();invoker.undo();invoker.undo();ReferenceCommand Pattern – Design Patterns (ep 7)Command","url":"/blog/software/design-pattern/command"}]}